# [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)

`递归` `Morris 遍历`

## 非递归遍历

### 解题思路

后序遍历的特点是先遍历左子树，再遍历右子树，最后是根节点

1. 利用栈收集左子树的左边节点，直至空节点
2. 弹出栈顶，此时需要判断该节点是否有右子树或者右节点是否已排序
    - 若弹出节点没有右子树或者右节点已排序，那么将节点加入已遍历的列表中
    - 若不符合上述条件（说明该节点还有右节点需要遍历，不能弹出舍弃），那么将节点重新压入栈，将当前节点更新为其右节点
3. 重复上述步骤，直至栈被清空和节点为空

### 复杂度

- 时间复杂度：O(N) 遍历二叉树的每一个节点
- 空间复杂度：O(N) 使用栈完成遍历，平均情况下为 O(logN)，logN 为树的高度，最坏情况是链状二叉树，为 O(N)

## 递归遍历

### 解题思路

递归遍历的实现与后序遍历的特性非常接近，先完成左子树的遍历，接着完成右子树的遍历，最后是根节点

1. 完成左子树的遍历，将遍历结果记录在参数 `order` 列表中
2. 完成右子树的遍历，同样记录遍历结果
3. 最后处理根节点

### 复杂度

- 时空复杂度与非递归遍历相同，区别在于递归隐式调用栈

## Morris 遍历

### 解题思路

待补充

## 复杂度

- 时间复杂度：O(N)，没有左子树的节点只会访问一下，有左子树的节点被访问两次
- 空间复杂度：O(1)，只操作树的空闲指针，使用常量空间


