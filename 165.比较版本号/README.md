# [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/solution/bi-jiao-ban-ben-hao-by-leetcode/)

`双指针`

## 字符串分割 + 逐个比较

比较直观的方法是将版本号字符串按 . 字符分割成块，然后逐块进行比较。如果两个版本号长度不一，需要较短的后面补充 0，与较长的版本进行比较

### 解题思路

1. 根据 . 字符分割两个版本号字符串并存储数组中
2. 遍历较长的数组，逐个比较，若其中一个数组结束，需要在后面添加 0，保证能与较长的数组的进行比较
3. 如果版本号不同，返回 1 或 -1，如果全部相同，返回 0

### 复杂度

- 时间复杂度：O(M + N + max(M, N))，其中 M 和 N 是输入字符串的长度
- 空间复杂度：O(N + M) 用于存储版本块的数组

## 双指针

考虑在每一个字符串上使用两个指针，跟踪每个数组的起始和结束位置，这样就能实现一遍分割块，一遍比较块，只需一次遍历和消耗常数空间就能解决问题

### 解题思路

1. 初始化指针 `p1` 和 `p2` 分别指向 `version1` 和 `version2` 的起始位置：`p1 = 0; p2 = 0`
2. 并行遍历两个字符串，在 `p1 < len(version1) or p2 < len(version2)` 的范围
    - 利用函数获取 `version1` 和 `version2` 的每一个版本块和下一个版本块的起始位置（用于更新 `p1` 和 `p2`），实现流程如下所示
    - 比较两版本块，如果不相同，则返回 1 或 -1，如果全部相同，返回 0

#### 获取版本块的函数实现

1. 块的起始由 `p` 指针标记，遍历版本字符串，寻找 . 字符的前一个位置 `end`，通过 `p` 和 `end` 截取版本块
2. 如果 `p` 指针已到达字符串的结尾，说明版本号解析完成，直接返回 0
3. 在返回版本块的同时，返回下一块的起始位置，用于下一块的比较

### 复杂度

- 时间复杂度：O(max(M, N))，其中 M 和 N 是输入字符串的长度
- 空间复杂度：O(1)

