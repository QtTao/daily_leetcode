# [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/)

`DFS` `BFS`

## [深度优先搜索](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

假设当前的位置是 `(i, j)`，那么从当前位置向上下左右 `(i + 1, j)`，`(i - 1, j)`，`(i, j - 1)`，`(i, j + 1)` 做搜索，当遇到越界或者不是未发现的陆地，停止搜索。在搜索陆地的过程中，**若遇到陆地，应将其标记为已访问**，以免之后重复搜索相同岛屿

### 解题思路

1. 在一个 `m x n` 的网格中，从上至下，左至右遍历网格，当 `grid[i][j] == '1'` 时，即发现陆地时
    - 岛屿数量 `num += 1`
    - 以 `(i, j)` 为起点，以深度优先遍历的方式找出相连的岛屿
        - 当 `(i, j)` 不在 `(m, n)` 范围内，停止搜索
        - 当 `grid[i][j]` 是海洋，或是已经访问过的陆地，同样停止搜索
        - 当 `grid[i][j]` 是未访问的陆地，首先将 `grid[i][j] = '2'` 表明当前位置已被发现，然后递归遍历其上下左右相连的位置
2. 当 `grid` 中全部都是海洋和已标记访问的陆地时，搜索结束，返回岛屿数量 `num`

### 复杂度

- 时间复杂度：O(M * N) 其中 M 和 N 分别网格的行数和列数
- 空间复杂度：O(M * N) 极端情况下，所有位置均为陆地，递归栈深度为 M * N

## [广度优先搜索](https://leetcode-cn.com/problems/number-of-islands/solution/number-of-islands-shen-du-you-xian-bian-li-dfs-or-/)

除了深度优先搜索，使用广度优先搜索同样可以实现对当前位置的上下左右相连位置进行搜索

### 解题思路

1. 同样地，在一个 `m x n` 的网格中，从上至下，左至右遍历网格，当 `grid[i][j] == '1'` 时，即发现陆地时
    - 岛屿数量 `num += 1`
    - 将当前位置 `(i, j)` 入队，然后弹出队首，判断是否为未访问的陆地，如果是
        - 将 `grid[i][j] = '2'` 标记为已访问
        - 同时将 `(i, j)` 的上下左右相连的位置一并入队，等待搜索和判断是否为陆地
        - 直至队列为空，说明以 `(i, j)` 的位置所在岛屿的所有陆地被标记为已访问
2. 当 `grid` 中全部都是海洋和已标记访问的陆地时，搜索结束，返回岛屿数量 `num`

### 复杂度

- 时间复杂度：O(M * N) 其中 M 和 N 分别网格的行数和列数
- 空间复杂度：O(M * n) 极端情况下，所有位置均为陆地，此时队列大小达到 M * N
