# [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/)
`二叉树后序遍历`

## 递归法

如果 root 是 p 和 q 节点的**最近公共祖先**，那么存在如下的情况：
- p 和 q 分布在 root 的两侧
- p = root，且 q 在 root 的某一子树中
- q = root，且 p 在 root 的某一子树中

### 解题思路

1. 如果当前节点 root 为空或者等于 p 节点或 q 节点，那直接返回 root
2. 递归搜索左子树，返回左子树中 p 和 q 的"最近公共祖先 left"（这里的最近公共祖先可能是 p 或 q 节点，也有可能是最终结果）
3. 递归搜索右子树，返回左子树中 p 和 q 的"最近公共祖先 right"
4. 如果 left 为空，则返回 right；如果 right 为空，则返回 left；
5. 如果 left 和 right 都不为空，说明 root 就是最近公共祖先

### 复杂度分析

- 时间复杂度：O(N) 遍历二叉树
- 空间复杂度：O(N) 递归栈深度，最坏的情况是链状二叉树，高度为 N

## 哈希表法

### 解题思路

利用哈希表存储所有节点的父节点，然后从 p 节点往上访问所有父节点，再从 q 节点往上访问父节点，直至出现已经访问过的父节点，这个就是最近公共祖先。
1. 从 root 开始后序遍历二叉树，存储所有节点的父节点到哈希表中
2. 基于哈希表，从 p 节点往上移动访问父节点，并使用另一个哈希表记录该节点是否访问
3. 从 q 节点往上访问父节点，直至找到访问过的节点，就是 p 和 q 的最近公共祖先

### 复杂度分析

- 时间复杂度：O(N) 遍历二叉树形成哈希表
- 空间复杂度：O(N) = O(N)：递归栈深度 + O(N)：哈希表存储
