# [47. 全排列II](https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/)

`回溯`

## 回溯

类似 [46. 全排列](https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/) 的做法，
这里也使用回溯算法枚举所有排列的可能性，再对重复的部分已经剪枝。根据题意，原始数组中含有重复元素，所以先对数组进行排序在进行回溯和剪枝

### 解题思路

1. 对数组 `nums` 就地进行从小到大排序，同时初始化标记数组，记录每一个数组下标的访问状态
2. 对数组下标进行遍历
    - 如果下标 `idx` 已被访问，跳过回溯过程
    - 如果该下标 `idx` 对应的元素与前一个下标 `idx - 1` 对应元素的相同，并且该下标访问状态已被撤销，说明使用 `idx` 的排列结果跟 `idx - 1` 的重复的，跳过回溯过程
    - 进入回溯过程
3. 在回溯过程中，标记下标的访问状态，已访问不用在使用，同时加入临时排序数组中，在回溯结束后，恢复原来的状态，撤销上次访问状态和弹出临时排序数组

### [`visited[idx - 1]` 与 `not visited[idx - 1]` 的区别](https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/)

- 首先在这两种剪枝条件都能够得到正确的答案
- `not visited[idx - 1]` 会在出现重复后第一时间进行剪枝，而 `visited[idx - 1]` 会在根节点进行剪枝
- 选择 `not visited[idx - 1]` 效率更高

```markdown
1. `not visited[idx - 1]` 剪枝过程
                                      [] 原数组 [1, 1', 2]
                                  [0, 0, 0]
                   /                  |(剪枝)                \  
                 [1]                 [1']                   [2]
              [1, 0, 0]            [0, 1, 0]               [0, 0, 1]
              /       \            /        \              /       \(剪枝)
          [1, 1']   [1, 2]     [1', 1]    [1', 2]       [2, 1]    [2, 1']
          [1, 1, 0] [1, 0, 1]  [1, 1, 0]  [0, 1, 0]     [1, 0, 1] [0, 1, 1]
            ｜        ｜          ｜          ｜           ｜         ｜
        [1, 1', 2] [1, 2, 1'] [1', 1, 2]  [1', 2, 1]  [2, 1, 1']  [2, 1', 1]
        [1, 1, 1]  [1, 1, 1]  [1, 1, 1]   [1, 1, 1]   [1, 1, 1]   [1, 1, 1]

2. `visited[idx - 1]` 剪枝过程
                                      [] 原数组 [1, 1', 2]
                                  [0, 0, 0]
                   /                  |                     \  
                 [1]                 [1']                   [2]
              [1, 0, 0]            [0, 1, 0]               [0, 0, 1]
              /       \            /        \              /       \
          [1, 1']   [1, 2]     [1', 1]    [1', 2]       [2, 1]    [2, 1']
          [1, 1, 0] [1, 0, 1]  [1, 1, 0]  [0, 1, 0]     [1, 0, 1] [0, 1, 1]
            ｜        ｜          ｜          ｜           ｜         ｜
        [1, 1', 2] [1, 2, 1'] [1', 1, 2]  [1', 2, 1]  [2, 1, 1']  [2, 1', 1]
        [1, 1, 1]  [1, 1, 1]  [1, 1, 1]   [1, 1, 1]   [1, 1, 1]   [1, 1, 1]
```

### 复杂度

- 时间复杂度：O(N * N!) = O(N) 拷贝数组复杂度 * O(N!) 回溯调用次数
- 空间复杂度：O(N * N!) 全排列个数 N!，另外考虑递归栈深度 O(logN) 和标记数组空间 O(N)
