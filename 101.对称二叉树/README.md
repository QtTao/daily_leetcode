# [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/)

`DFS` `BFS`

## 深度优先搜索

对称的二叉树与 [100.相同的树](https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/) 不同点在于**每个树的右子树都与另一个树的左子树镜像对称**

### 解题思路

1. 首先判断左右子树头结点是否相同
   - 如果都为空，对称
   - 如果其中一个为空，另一个为非空，非对称
   - 如果都为非空，但值不同，非对称
2. 如果左右子树头结点都为非空，且值相同，递归遍历二叉，比较
   - 左结点的左子结点与右结点的右子结点是否对称
   - 左结点的右子结点与右结点的左子结点是否对称

### 复杂度

- 时间复杂度：O(N) N 为二叉树的结点数
- 空间复杂度：O(N) 递归调用栈深度不超过 N

## 广度优先搜索

检查二叉树是否镜像对称也可以使用广度优先搜索，关键在于**左右结点的子结点入队顺序**

### 解题思路

1. 首先初始化两队列 `queue1` 和 `queue2`，分别存放左右子树的结点，并将根结点入队
2. 广度优先遍历，将左右结点出队
   - 当左右子结点为空，比较下一个出队的结点
   - 当一个结点为空，另一个结点非空，或者两结点的值不相同，说明非对称
   - 将左右结点的子结点入队，这里注意入队顺序
     - 对于 `queue1`，首先入队的是左结点的左子结点，随后是左结点的右子结点
     - 对于 `queue2`，首先入队的是右结点的右子结点，随后是右结点的左子结点

### 复杂度

- 时间复杂度：O(N) N 为二叉树的结点数
- 空间复杂度：O(N) 队列中最多不会超过 N 个结点
