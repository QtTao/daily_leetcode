# [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/)

`动态规划` `记忆化回溯`

## 动态规划

假设 `dp[i]` 为组成金额 i 所需的最少硬币数量，而可选硬币面额有 n 枚，分别是 `c0, c1, ... cn-1`，由此可以构造出状态转移关系 `dp[i] = min(dp[i - c0], dp[i, c1], dp[i - c2], ..., dp[i -cn-1]) + 1`，表示在枚举最后一枚硬币的面额是
cj，需要从 `dp[i - cj]` 的状态转移过来，再加上最后一枚硬币

### 解题思路

1. 初始化状态数组 `dp = [float('inf'), ..., float('inf')]` 一共有 `amount + 1` 个状态，包括第一个状态 `dp[0] = 0` 表示金额 0 无法用硬币组成
2. 先遍历硬币，再遍历金额数，通过 `min(dp[i], dp[i - coin] + 1)` 计算每个金额下的最少硬币数量
3. 完成遍历后，得到金额 amount 下的最少硬币数量，或者状态一直维持 `float('inf')` 说明无法使用硬币组成金额

### 复杂度

- 时间复杂度：O(金额 * 硬币数) 在计算每个 O(金额) 状态，需要枚举硬币数的转移状体啊，所以需要 O(金额 * 硬币数) 的时间复杂度
- 空间复杂度：O(金额) 需要数组长度为金额的空间

## 记忆化回溯

根据方法一中的状态转移关系，可以通过记忆化回溯来深度优先遍历所有状态，最终返回硬币数量的最小值，或者 -1，下图展示了金额为 6，硬币为 `[1, 2, 3]` 的所有递归遍历状态，其中有很多状态被多次计算，所以可以对其进行记忆化，优化搜索过程

![记忆化回溯递归树](https://i.loli.net/2021/06/03/BIbdLjChF75OPvi.png)

### 解题思路

1. 构造记忆化回溯函数 `memory_seach`，可使用 `functool.lru_cache` 对搜索结果进行缓存
    - 当金额为 0 时，返回 0 个硬币
    - 初始化硬币数量为 `coin_num = float('inf')`
    - 遍历硬币所有面额，深度优先搜索金额从 0 到 amount 的所有状态
        - 若金额小于硬币面额，直接跳过，不用考虑
        - 若当前金额所用的硬币数为所有硬币面额的对应硬币数量的最小值，那么更新当前金额下的最少硬币数
        - 若当前金额所有的硬币数不是所有硬币面额的对应硬币数量的最小值，直接跳过，不用更新当前金额的硬币数
2. 返回金额为 amount 的状态，即组成 amount 的最少硬币数

### 复杂度

- 时间复杂度：O(金额 * 硬币数) 每个状态需要遍历所有硬币面额，且一共有 O(金额) 个状态
- 空间复杂度：O(金额) 额外开启 O(金额) 空间来进行记忆化回溯
