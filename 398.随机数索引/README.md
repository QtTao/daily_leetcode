# [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/solution/398-sui-ji-shu-suo-yin-shui-tang-chou-ya-ud8b/)

`Reservoir Sampling`

## [Reservoir Sampling](https://blog.csdn.net/anshuai_aw1/article/details/88750673)

蓄水池抽样主要针对无法一次性全部加载到内存中的未知数据规模，以等概率的方式抽取 n 个数据，假设需要抽样的数量是 k，首先构建一个可容纳 k 个元素的数组中，将序列中的前 k 个元素加入数组中，然后从第 `j (j > k)` 个元素开始，**以 `k / j` 的概率来决定这个元素是否被替换到数组中**，而数组中的 k
个元素被替换的概率是相同的。当遍历完所有元素之后，剩余元素就是等概率下抽取的样本

如何证明这个抽样方式是等概率的？

- 对于第 i 个数 `(i <= k)`，在 `k + 1` 时，它被第 `k + 1` 个元素替换的概率 = 第 `k + 1` 个元素被选中的概率 * 第 i 个数被选中替换的概率，即 `k / (k + 1) * 1 / k = 1 / (k + 1)`，换言之，它不被第 `k + 1`
  个元素替换的概率为 `k / (k + 1)`，如此类推，不被第 `k + 2` 个元素替换的概率为 `(k + 1) / (k + 2)`，遍历完序列后，第 i 个元素被保留的概率 = 被选中的概率 * 不被替换的概率 = `1 * k / (k + 1) * (k + 1) / (k + 2) * ... * (n - 1) / n = k / n`
- 对于第 j 个数 `(j > k)`，在 j 时，被选中的概率为 `k / j`，它不被第 `j + 1` 个元素替换的概率为 `1 - k / (j + 1) * 1 / k = j / (j + 1)`，遍历完序列后，它被保留的概率 = 被选中的概率 * 不被替换的概率
  = `k / j * j / (j + 1) * (j + 1) / (j + 2) * ... * (n - 1) / n = k / n`
- 故对于每一个元素，被保留下来的概率均为 `k / n`

### 解题思路

1. 初始化 `n = 1`，用于记录数组中元素等于目标值时的索引值个数，目标索引 `ans = None`
2. 遍历数组，当元素等于目标值时
    - 根据题意只需要保留一个索引值，因此以 `1 / n` 概率更新目标索引，第一次更新时，`random.randrange(0, 1) < 1` 恒成立，所以目标索引一定会更新的
    - `n += 1` 更新索引值个数，用于计算下次索引是否更新的概率值 `1 / n`
3. 结束遍历，返回索引值    

### 复杂度

- 时间复杂度：O(N) 其中 N 是数组元素的个数
- 空间复杂度：O(1) 没有使用额外空间
