# [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/)

`DFS`

## 深度优先遍历（自顶向下）

平衡二叉树是二叉树的每个结点的左右子树高度差绝对值不超过 1，因此如果一颗二叉树是平衡二叉树，那么所有子树都是平衡二叉树

### 解题思路

1. 判断根结点是否为空，如果为空，则是平衡的
2. 计算根结点的左右子树高度差绝对值，二叉树的最大高度实现方式可以参考[这里](../104.二叉树的最大深度/solution.py)，如果不超过 1，递归判断以左右子树为根结点的二叉树的平衡性

### 复杂度

- 时间复杂度：O(N^2) N 为二叉树结点的个数
- 空间复杂度：O(H) H 为二叉树高度，最坏情况是链状二叉树，O(H) = O(N)

## 深度优先遍历（自底向上）

由于自顶向下计算每个子树的最大深度会造成冗余，容易超时，考虑采用自底向上递归，从叶结点开始计算高度，同时判断高度差的绝对值是否超过 1，直至所有结点都被访问一次或者在某次比较中发现不平衡二叉树

### 解题思路

1. 类似二叉树的后序遍历，从左子树底部开始计算二叉树高度，同时一旦出现高度差绝对值超过 1， 令变量 `is_balanced = False`
2. 如果左子树为平衡树，那么同样地，从右子树底部计算高度，如果存在不平衡子树，也令变量 `is_balanced = False`
3. 在自底向上递归的过程中，一旦出现不平衡子树，就可以结束剩余的遍历，直接返回结果，所以递归终止的条件是 `root is None or not is_balanced`

### 复杂度

- 时间复杂度：O(N) 每个结点只会被访问一次
- 空间复杂度：O(H) H 为二叉树高度，最坏情况是链状二叉树，O(H) = O(N) 
