# [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/)

`DFS` `BFS`

## 深度优先搜索

合并二叉树的过程本质就是对二叉树进行深度优先搜索，从根节点开始同时遍历两个二叉树，并将对应的节点进行合并

### 解题思路

1. 如果两个二叉树的的对应节点都为 `None`，则合并后的二叉树的对应节点也是 `None`
2. 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树节点就是其中的非空节点
3. 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值就是两节点的值之和，另外还要连接左子树和右子树的合并结果

### 复杂度

- 时间复杂度：O(min(M, N)) 其中 M 和 N 分别是两个二叉树的节点数，只有当两个二叉树的对应节点都不为空，才会对该节点进行合并操作，
- 空间复杂度：O(min(M, N)) 空间复杂度取决于递归调用的层数，不会超过较小的二叉树的最大高度

## 广度优先搜索

除了对二叉树进行深度优先搜索，也可以通过广度优先搜索进行合并，分别用三个队列存储合并后的二叉树节点以及原始二叉树节点，然后利用队列先进先去的特性逐层合并节点

### 解题思路

1. 初始时，将每个二叉树的根节点分别加入相应的队列
2. 每次从队列中取出一个节点，判断两个原始二叉树节点是否为空。如果两个原始二叉树的节点中至少有一个节点不为空，则合并后的二叉树的对应节点也不为空，左右子节点同理
3. 每层合并完的二叉树节点按照从左往右的顺序入队，出队也是逐层进行的

### 复杂度

- 时间复杂度：O(N) N 为合并后二叉树的节点数
- 空间复杂度：O(N)
