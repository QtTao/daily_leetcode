# [350. 两个数组的交集II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/)

`哈希表` `排序` `双指针`

## 哈希表

由于同一个数字在两个数组中都可能出现多次，故需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值

### 解题思路

1. 首先遍历元素较少的数组，并使用哈希表 `counter` 记录它的每个数字以及对应出现的次数
2. 然后遍历元素较多的数组，对于第二个数组中的每个数字，如果在 `counter` 中存在这个数字，则将它加入结果数组 `ans`，同时减少 `counter` 中该数字出现的次数
3. 当 `counter` 中某个数字出现次数降到 0，就将它剔除，确保数字出现次数不超过在两个数组中出现次数的最小值
4. 对元素较少的数组完成遍历后，返回结果数组 `ans`

### 复杂度

- 时间复杂度：O(M + N) 其中 M 和 N 分别是两个数组的长度，需遍历两个数组进行创建哈希表创建和查询
- 空间复杂度：O(min(M, N)) 对较短的数组进行哈希表操作，所以哈希表大小不会超过较短的数组的长度

## 排序 + 双指针

如果两个数组有序，可以使用双指针的方法得到两个数组的交集

### 解题思路

1. 先对两个数组进行排序，然后使用双指针遍历两个数组，其中 i 对应 `nums1`，j 对应 `nums2`
2. 初始时，两个指针指向数组的头部，每次比较两个指针指向的两个数组中对应的数字
    - 如果两个数字不相等，则将指向较小数字的指针右移一位
    - 如果两个数字相等，将该数字加入结果数组 `ans` ，并将两个指针右移一位
3. 当至少有一个指针超出数组范围时，结束遍历，返回结果数组 `ans`

### 复杂度

- 时间复杂度：O(MlogM + NlogN) 其中 M 和 N 分别为两个数组的长度，对数组进行排序的时间复杂度为 O(MlogM + NlogN)，遍历两个数组的时间复杂度为 O(M + N)，所以整体的时间复杂度为 O(MlogM + NlogN)
- 空间复杂度：O(logM + logN) 排序所需的额外空间为 O(logM + logN)

## 两种方法的对比

如果元素较多的数组 `nums2` 存储在磁盘中，内存是有限的前提下，不能一次加载所有的元素到内存中，那么就无法高效地对 `nums2` 进行排序，因此推荐使用方法一而不是方法二，在方法一中，`nums2` 只关系到查询操作，每次读取 `nums2` 中的一部分数据，并进行处理即可 
