# [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/)

`哈希表` `双向链表`

## [哈希表 + 双向链表](https://leetcode-cn.com/problems/lru-cache/solution/shu-ju-jie-gou-fen-xi-python-ha-xi-shuang-xiang-li/)

LRU 缓存机制可以通过哈希表辅以双向链表实现

- 双向链表用来按顺序存储键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的
- 哈希表用来缓存数据的键，映射到其在双向链表中的位置

### 解题思路

- get 操作
    - 如果 key 不存在，返回 -1
    - 如果 key 存在，通过哈希表定位该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值
- put 操作
    - 如果 key 不存在，**先判断当前双向链表节点数是否超出容量，如果超出容量，则删除双向链表尾部节点，同时删除哈希表中的对应项**，然后直接在双向链表头部添加该节点，并将该节点添加进哈希表中
    - 如果 key 存在，通过哈希表定位该节点，然后将节点值更新，**并将节点移动到双向链表的头部**
- 小技巧
    - 为了避免在添加和删除节点的时候检查相邻节点是否存在，可以在双向链表中添加伪头部和伪尾部节点

### 复杂度

- 时间复杂度：O(1) 利用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表头部，即可在 O(1) 完成 get 和 put 操作
- 空间复杂度：O(N) 哈希表和双向链表储存 N 个元素
