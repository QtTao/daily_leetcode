# [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode-solution/)

`动态规划` `Manacher`

## [动态规划](https://leetcode-cn.com/problems/palindromic-substrings/solution/shu-ju-jie-gou-he-suan-fa-dong-tai-gui-h-3bms/)

假定 `dp[i][j]` 表示字符串中从下标 i 到 j 是否为回文串，如果 `dp[i][j] = True`，则表示是回文串，否则不是回文串，进一步分析各种情况

- 当 i = j，单字符必定是回文串，故 `dp[i][j] = True`
- 当 j - i = 1，若 `s[i] == s[j]`，两个相同字符也是回文串，故 `dp[i][j] = (s[i] == s[j])`
- 当 j - i >= 2，若 `s[i] == s[j]`，且 `s[i + 1:j]` 也是回文串，那么 `s[i:j + 1]` 也是回文串，故 `dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]`

综上所述，回文子串转化成动态规划问题，这里需要注意 `dp[i][j]` 依赖 `dp[i + 1][j - 1]` 的状态，更新状态时遍历的方向可以先从左往右，然后从上往下进行

### 解题思路

1. 初始化 n x n 二维状态矩阵 `dp`，值为 False
2. 先从左往右建立外层循环，设下标为 j，其中 `j ∈ [0, n - 1]`
3. 然后从上往下建立内层循环，设下标为 i，注意下标 i <= 下标 j，其中 `i ∈ [0, j]`
4. 当 `s[i] != s[j]`，说明 `dp[i][j] = False`，由于初始值就是 False，这里可以直接进入下一个循环
5. 当 `s[i] == s[j]`，这里有三种情况需要考虑
    - 下标 i 和下标 j 之间的字符数量不多于一个，那么 `dp[i][j] = True`
    - 如果多于一个，且下标 i 和下标 j 之间的也是回文串，那么 `dp[i][j] = True`
    - 否则 `dp[i][j] = False`，直接进入下一个循环

### 复杂度

- 时间复杂度：O(N^2) 其中 N 为字符串长度
- 空间复杂度：O(N) 通过滚动数组可以将空间降低至一维数组

## [中心扩展](https://leetcode-cn.com/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/)

对字符串 `ababa`，如果选择最中间的 `a` 作为中心点，向两边扩展，第一次扩展发现 `left` 左边界指向的是 `b`，而  `right` 右边界指向的也是 `b` ，所以得到新的回文串，继续扩展后，同理 `ababa`
也是回文串。通过确定的中心点向两边扩展，就能找出所有回文子串。问题的关键在于如何有序地找出所有回文中心？因为回文中心既可以是单字符，如 `aba`，又可以是双字符，如 `abba`，所以回文中心的有 `2 * len(s) - 1` 个，其中分别有 `len(s)` 个单字符和 `len(s) - 1` 个双字符

### 解题思路

1. 遍历回文中心 `2 * len(s) - 1`，并确定回文中心的左边界  `left` 和右边界 `right`
    - **`left = center / 2` 左边界是回文中心点的 `1/2` 处**
    - **`right = left + center % 2` 右边界要么等于左边界，如单字符回文中心，要么等于左边界 + 1，如双字符回文中心**
2. 当左边界指向的字符与右边界指向的字符相同，可以认为找到了一个回文串，向两边扩展，继续搜索下一个回文串

### 复杂度

- 时间复杂度：O(N^2)  = O(N) 遍历回文中心 * O(N) 中心扩展
- 空间复杂度：O(1)

## [Manacher 算法](https://writings.sh/post/algorithm-longest-palindromic-substring#manacher-方法)

`Manacher` 算法背后也是基于动态规划思想的，主要分为两个过程

1. 预处理：通过插入分隔符 `#`，把潜在回文子串转换为奇数长度，预处理时可以在字符串首尾加入特殊字符，避免中心扩展时越界
2. 状态转移：构造回文半径数组，利用回文的对称性，递推回文半径

**回文半径**：回文子串的中心字符到左边界的距离，此处的定义是包含中心点，比如 `abc` 以 `b` 为中心的回文半径是 2

考虑 `f[i]` 表示预处理后字符串的第 i 位为回文中心，向两边扩展的最大回文半径，由此可知第 i 个字符的最大回文串长度为 `f(i) - 1`，最大长度的一半即以 i 为中心的回文串个数

在遍历字符时，需维护当前最长回文串，包括两个方面的信息

- 它的中心字符位置 `im`
- 它的右边界位置 `rm`，容易得到右边界 `rm = i + f[i] - 1`

假设当前最长回文串的中心点是 `im` 和右边界是 `rm`，那么第 i 位为中心的最长回文串有以下三种可能

- 它的中心点和右边界都在 `rm` 的左侧，即当前最长回文串可以完全覆盖以 i 为中心的最长回文串，那么 i 关于中心 `im` 的对称位置 j，两边完全镜像，最长回文半径相同
- 它的中心点在 `rm` 的左侧，而右边界在 `rm` 的右侧，容易得知以 i 为中心的回文半径至少 `rm - i + 1`
- 它的中心点和右边界都在 `rm` 的右侧，此时以 i 为中心回文半径未知，可从 i 开始向两边扩展求出

### 解题思路

1. 预处理字符串，加入分隔符 `#`，首尾加入 `$` 和 `!` ，避免中心扩展时越界，预处理后的字符串为 `t`
2. 遍历字符串，更新最大回文半径数组 `f[i]`
    - 当前位置 `t[i]` 在当前最长回文串的右边界左侧，那么先初始化 `f[i] = min(rm - i + 1, f[2 * im - 1])`，保证以 `t[i]` 为中心的回文串在当前最大回文串内
    - 当前位置 `t[i]` 在当前最长回文串的右边界右侧，`f[i] = 0`
3. 以 `t[i]` 为中心向两边扩展，判断 `t[i + f[i]] == t[i - f[i]]`，若条件为真，更新回文半径 `f[i] += 1`
4. 动态维护当前最长回文串，包括回文串中心 `im` 和右边界 `rm`
5. 由于字符串中加入分隔符 `#`，回文子串个数 `ans` 跟  `t[i]` 的最长回文半径的关系是 `ans = (f[i] - 1) // 2`，叠加所有中心的回文子串个数就是最终答案

### 复杂度

- 时间复杂度：O(N) N 为字符串长度，待证明
- 空间复杂度：O(N)
