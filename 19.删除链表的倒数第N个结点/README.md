# [19. 删除链表的倒数第N个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/)

`数组` `双指针`

## 数组

由于链表无法用下标进行访问，所以将链表转换成数组，通过下标找到倒数第 N 个结点

### 解题思路

1. 创建哑结点，连接头结点
2. 遍历链表，并将结点存储到数组中
3. 根据参数，删除结点
    - 如果删除的是头结点，即 N 为数组的长度，使用哑结点连接第二个结点即可
    - 如果删除的是其他结点，通过数组访问被删除结点的前驱结点 `node`，通过 `node.next = node.next.next` 删除

### 复杂度

- 时间复杂度：O(N) 遍历链表
- 空间复杂度：O(N) 数组中保存链表结点

## 双指针

由于需要找到倒数第 N 个结点，可以使用两个指针 `front` 和 `back` 同时对链表进行遍历，并且 `front` 比 `back` 超前 N 个结点。当 `front` 遍历到链表的末尾时，`back` 就恰好处于倒数第 N 个结点。如果我们能够得到的是倒数第 N 个结点的前驱结点而不是倒数第 N
个结点的话，删除操作会更加方便。可以考虑在初始时将 `back` 指向哑结点，其余的操作步骤不变。这样一来，当遍历到链表的末尾时，`back` 的下一个结点就是我们需要删除的结点

### 解题思路

1. 创建哑结点 `dummy`，连接头结点 `head`
2. 让 `front` 指针指向 `head`, `back` 指针指向 `dummy`，两指针相差一个位置
3. 先让 `front`  先前移动 N 个位置，这时两指针相差 N + 1 位置
4. `front` 和 `back` 指针同步向前，直至 `front` 到达链表尾部，这时 `back` 指针位于删除结点的前驱结点
5. `back.next = back.next.next` 删除结点

### 复杂度

- 时间复杂度：O(N) 前后指针分别遍历链表
- 空间复杂度：O(1)
