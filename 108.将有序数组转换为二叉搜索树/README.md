# [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jian-dan-di-gui-bi-xu-miao-dong-by-sweetiee/)

`DFS`

## 深度优先遍历

[二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/tu-jie-er-cha-sou-suo-shu-gou-zao-di-gui-python-go/)

1. 若任意结点的左子树不空，则左子树的所有结点的值均小于它的根结点的值
2. 若任意结点的右子树不空，则右子树的所有结点的值均大于它的根结点的值
3. 任意结点的左右子树也分别为二叉搜索树
4. 没有键值相等的结点
5. 二叉搜索树可以是一颗空树

**二叉搜索树的中序遍历是升序数组**，但如果只有升序数组，无法唯一确定二叉搜索树，而事实上数组中**任何一个数字**都可以作为二叉搜索树的根结点，因此可能的二叉搜索树有多个。如果增加高度平衡的条件，仍然无法确定唯一的二叉搜索树，这是因为**当数组长度为偶数**
时，可以选择中间位置靠左或者靠右的数字作为二叉树的根结点，选择不同的数字作为根结点创建的高度平衡的二叉搜索树也是不同的

注意当确定平衡二叉搜索树的根结点后，其余数字会分布在左子树和右子树中，而左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式构建平衡二叉搜索树

### 解题思路

1. 选择中间位置的数字作为根结点
    - 靠左边的下标 `mid = (left + right) // 2`
    - 靠右边的下标 `mid = (left + right + 1) // 2`
    - 选择任意一个中间位置 `mid = ((left + right) + randint(0, 1)) // 2`
2. 利用 `mid` 左边的数组递归构建平衡二叉搜索树的左子树，而 `mid` 右边的数组构建右子树
3. 递归结束条件是当左边界 `left` 大于右边界 `right` 返回空结点，用于连接叶结点

### 复杂度

- 时间复杂度：O(N) N 为数组长度，每个数字只会访问一次
- 空间复杂度：O(logN) 递归调用栈深度为二叉树的高度 logN
