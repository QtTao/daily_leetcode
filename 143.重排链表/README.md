# [134. 重排链表](https://leetcode-cn.com/problems/reorder-list/solution/zhong-pai-lian-biao-by-leetcode-solution/)

## 线性表

### 解题思路

由于链表不支持随机访问，所以将链表转换为线性表，支持通过下标访问

1. 遍历链表，转存至线性表
2. 创建头尾指针，通过头尾节点的关联，实现链表重排
3. 先头部节点连接尾部节点，头指针向前移动一步
4. 判断头尾指针是否重叠，若重叠，退出循环
5. 将尾部节点连接第二个节点，尾指针向后移动一步
6. 退出循环后，将最后节点指向 None

### 复杂度

- 时间复杂度：O(N) 遍历两次链表，实现重排
- 空间复杂度：O(N) 将链表节点按顺序存储于线性表

## 链表反转 + 合并

### 解题思路

重排链表是将原链表的左半部分和反转后的右半部分合并后的结果

1. 利用快慢指针搜索链表的中间节点（Leetcode 876）
2. 基于步骤 1 的中间节点，将链表分成左右链表
3. 将右半链表反转（Leetcode 206）
4. 将左右链表合并

### 复杂度

- 时间复杂度：O(N) = O(N) 搜索链表中间节点 + O(N) 反转链表 + O(N) 合并链表
- 空间复杂度：O(1) 常量空间保存链表指针

## [递归](https://leetcode-cn.com/problems/reorder-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-34/)

### 解题思路

将原问题拆分成子问题，如果递归函数能够返回当前头节点和对应的尾节点，并且将头节点和尾节点之间的链表按题意调整顺序，那么就可以使用递归完成链表重排

1. 计算链表节点个数
2. 处理只有一个和两个节点的情况作为递归出口
3. 递归处理头节点和尾节点的链表重排，同时返回递归函数参数头节点对应的尾节点，注意递归函数参数的设置

### 复杂度

- 时间复杂度：O(N) = O(N) 计算节点个数 + O(N) 递归遍历节点，调整顺序
- 空间复杂度：O(N) 递归栈调用
