# [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/)

`Fisher-Yates` `Inside-Out`

## 暴力解法

随机地从数组中抽取元素，每一个元素被不放回抽中的概率都是 `1/n`，这表示该数组的每个排序都是等概率

### 解题思路

1. 为实现不放回抽取，需对数组元素进行移除，所以复制一份数组
2. 遍历数组下标，随机从复制数组中抽取一个下标 `random.randrange(复制数组的长度)`
3. 每次随机取完下标，将该元素从复制数组移除 `复制数组.pop(index)`，然后将返回值在原数组中重新排列
4. 完成下标遍历

### 等概率证明

1. 元素 A 在第一轮被选中的概率为 `1/n`
2. 元素 A 在第二轮被选中的概率为 `(n-1)/n*1/(n-1)=1/n`
3. 元素 B 在第二轮被选中的概率为 `(n-1)/n*(n-2)/(n-1)*1/(n-2)=1/n`
4. 如此类推

### 复杂度：

- 时间复杂度：O(N^2) 遍历数组，然后从备份数组中删除对应元素
- 空间复杂度：O(N) = O(N) 保存初始状态 + O(N) 创建备份数组

## [Fisher-Yates 洗牌算法](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle)

### 解题思路

1. 遍历数组下标
2. 假设当前数组下标为 `idx`，从 `[idx, n]` 随机抽取一个下标 `new_idx`
3. 交换两个下标，将随机选择的元素按顺序填充数组，实现原地修改
4. 完成下标遍历

### 复杂度

- 时间复杂度：O(N) 一次遍历数组，原地修改数组
- 空间复杂度：O(N) 用于重置数组

## [Inside-Out 洗牌算法](https://github.com/zijundeng/Interview_Notes-Chinese/blob/master/算法/专题-洗牌与采样.md#inside-out-shuffle)

`Fisher-Yates` 需要改动原数组，有时候需要保留原数组的顺序，这时可以先复制原数组，然后借助原数组对复制数组进行洗牌

### 解题思路

1. 复制数组
2. 遍历数组下标，在 **`[0, i]`** 之间随机选择下标 `j`，然后用 `j` 位置元素替换 `i` 位置的元素
3. 用**原数组**中位置 `i` 的元素替换复制数组中位置 `j` 的元素（相当于 `Fisher-Yates` 算法中在原数组中交换 `i` 和 `j` 的位置）
4. 完成下标遍历

### 复杂度

时空复杂度与 `Fisher-Yates` 一致

