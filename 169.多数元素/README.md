# [169. 多数元素](https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/)

`哈希表` `分治法` `投票法`

## 哈希表

利用哈希表记录每一个数字出现的次数，出现次数最多的数字就是多数元素

### 解题思路

1. 遍历数组，记录每个数字出现次数
2. 在遍历的过程中，维护当前出现次数最多的元素

### 复杂度

- 时间复杂度：O(N) 遍历数组
- 空间复杂度：O(N) 哈希表中最多包含 `n / 2` 的键值对，所以占用空间是 O(N)

## 分治法

如果某个数字是数组的众数，将数组分成左右两部分，分别求出左半部分的众数 `left` 以及右半部分的众数 `right`，随后在 `left` 和 `right` 中选出正确的众数

### 解题思路

1. 将数组分成左右两部分，注意计算中间下标时不要越界 `mid = (right - left) // 2 + left`
2. 分别递归计算左右两边的众数，为 `left` 和 `right`
    - 如果 `left` 和 `right` 相同，直接返回
    - 如果数组只有一个元素，或者数组上下界重合，直接返回对应下标的元素
    - 如果两者不同，比较两个众数在整个区间内出现的次数来决定该区间的众数

### 复杂度

- **时间复杂度**：O(NlogN)
- 空间复杂度：O(logN) 递归调用栈空间

## Boyer-Moore 投票法

将数组看作选举票仓，那一方的票数多于 `n / 2` 就成功当选

### 解题思路

1. 遍历数组，并初始化候选人和支持票数，其中支持票数为 0
2. 当支持票数下降为 0 时，更换候选人
3. 当候选人跟当前的元素相同，支持票数加一，否则减一
4. 完成遍历后，前期当选人的支持者会跟非支持者数量相互抵消，最后候选人支持票数大于 0，候选人当选

### 复杂度

- 时间复杂度：O(N)
- 空间复杂度：O(1)

