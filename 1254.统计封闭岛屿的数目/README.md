# [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/solution/c-python3-dfsji-yi-hua-zhi-jie-zai-gridz-x2tw/)

`DFS` `BFS`

## 深度优先搜索

通过深度优先搜索遍历岛屿连通的所有陆地，同时判断岛屿的边界是否超出网格的范围，如果超出，说明不是封闭岛屿

### 解题思路

1. 从上至下，左至右搜索 `m x n` 网格，当 `grid[i][j] == 0`，开始深度优先搜索
    - 首先判断 `(i, j)` 是否在网格范围内，如果不在，说明不是封闭岛屿
    - 如果 `(i, j)` 在网格范围内，且 `grid[i][j]` 是水域或者已访问过的陆地，说明当前岛屿还是封闭的
    - 如果 `(i, j)` 在网格范围内，且 `grid[i][j]` 是未访问过的陆地，标记已访问，然后向四周进行搜索，只有上下左右的位置都是封闭的，才能说明岛屿是封闭的
2. 找出网格所有岛屿，并完成深度优先遍历，最后得到封闭岛屿的数目

### 复杂度

- 时间复杂度：O(M * N) 其中 M 和 N 分别是网格的行数和列数
- 空间复杂度：O(M * N) 递归调用栈最大深度是网格的大小，为 M * N

## 广度优先搜索

同理，广度优先搜索也可以找出岛屿连通的所有陆地，然后判断岛屿是否为封闭的

### 解题思路

1. 从上至下，左至右搜索 `m x n` 网格，当 `grid[i][j] == 0`，开始广度优先搜索
    - 首先将 `(i, j)` 入队
    - 弹出队首，判断 `(i, j)` 是否在网格范围内，如果不在，说明不是封闭岛屿
    - 如果 `(i, j)` 在网格范围内，且 `grid[i][j]` 是水域或者已访问过的陆地，继续弹出队首
    - 如果 `(i, j)` 在网格范围内，且 `grid[i][j]` 是未访问过的陆地，标记已访问，然后将四周的位置加入队列，等待下一轮的搜索
    - 使用广度优先搜索注意即使遇到超出边界的情况也不能停止搜索，中断的后果是岛屿被割裂，影响下一轮搜索
2. 通过广度优先搜索找出所有岛屿，最后得到封闭岛屿的数目

### 复杂度

- 时间复杂度：O(M * N) 其中 M 和 N 分别是网格的行数和列数
- 空间复杂度：O(M * N) 当网格内所有都是陆地时，队列的大小为网格的大小
