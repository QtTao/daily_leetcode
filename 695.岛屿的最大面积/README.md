# [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/)

`DFS` `BFS`

## 深度优先搜索

深度优先搜索的思想是将岛屿中连通的所有陆地搜索出来，然后进行统计，最后取每一块连通形状面积的最大值

### 解题思路

1. 从上至下，左至右遍历 `m x n` 的网格，当遇到未访问的陆地时，即 `grid[i][j] = 1` ，以深度优先搜索的方式遍历岛屿的所有陆地
    - 初始化岛屿面积 `area = 0`
    - 当 `(i, j)` 在网格范围内，且 `grid[i][j] = 1` ，岛屿面积 `area += 1`，同时标记 `grid[i][j] = 2` 为已访问
    - 以 `(i, j)` 为中心，向四周搜索相连的陆地，直至该岛屿的所有陆地都被标记为 2
2. 搜索网格中所有的岛屿，计算其面积，最后得到最大岛屿的面积

### 复杂度

- 时间复杂度：O(M * N) 其中 M 和 N 分别是网格的行数和列数
- 空间复杂度：O(M * N) 递归的深度最大可能是整个网格的大小，为 M * N

## 广度优先搜索

类似地，广度优先搜索也能将岛屿中连通的所有陆地搜索出来，计算其面积，最后获得最大值

### 解题思路

1. 从上至下，左至右遍历 `m x n` 的网格，当 `grid[i][j] = 1` 时，初始化岛屿面积将 `(i, j)` 入队，以广度优先搜索的方式遍历该岛屿的所有陆地
    - 当 `(i, j)` 在网格范围内，且 `grid[i][j] = 1`, 岛屿面积 `area += 1`，同时标记 `grid[i][j] = 2` 为已访问
    - 以 `(i, j)` 为中心，将上下左右四个位置，加入队列，等待搜索
    - 当岛屿的所有陆地被标记为 2，结束搜索，返回岛屿面积 `area`
2. 搜索网格中所有的岛屿，最后得到最大岛屿的面积

### 复杂度

- 时间复杂度：O(M * N) 其中 M 和 N 分别是网格的行数和列数
- 空间复杂度：O(M * N) 队列的大小可能是网格的大小，为 M * N
