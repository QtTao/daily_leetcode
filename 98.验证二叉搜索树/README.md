# [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/)

`DFS`

## 深度优先遍历

二叉搜索树的定义

- 如果该二叉树的左子树非空，则左子树上**所有结点**的值均小于它的根节点的值
- 如果右子树非空，则右子树上**所有结点**的值均大于它的根节点的值
- 空树也属于二叉搜索树

### 解题思路（自底而上）

1. 设计递归函数 `dfs(root, lower, upper)` 来验证二叉搜索树，函数考虑以 `root` 为根结点的子树，判断子树中所有结点的值是否都在 `(lower, upper)` 的范围内
2. 在验证左子树时，`upper` 应更新为 `root.val`，表示左子树所有结点均小于根结点的值，同理在验证右子树时，`lower` 应更新为 `root.val`，表示右子树所有结点均大于根结点的值
4. 最后验证 `root` 的值是否在 `(lower, upper)` 的范围内，直接返回 False，否则继续向上递归调用检查父结点是否满足二叉搜索树的条件
5. `dfs(root, lower=-inf, upper=inf)` 函数递归调用的入口

### 复杂度

- 时间复杂度：O(N) N 为二叉树的结点数
- 空间复杂度：O(H) H 为二叉树的高度，平均情况下为 logN

## 中序遍历

二叉搜索树的中序遍历得到的值构成的序列一定是升序的，考虑在中序遍历时实时检查当前结点的值是否大于前一个中序遍历的结点的值即可。如果得到的序列是升序，整棵树就是二叉搜索树，否则不是，实现中序遍历可以使用递归和非递归两种方式，下面以非递归方式说明解题思路

### 解题思路

1. 初始化栈 `stack` 和当前最小值 `min_val = float('-inf')`
2. 按照中序遍历的结点访问顺序（左-中-右），先将二叉树左侧的所有结点入栈
3. 弹出栈顶结点，判断结点值与前一个值大小，如果小于等于前一个值，说明不是二叉搜索树，否则更新当前最小值，和更新弹出的结点为右子结点，中序遍历有多种实现方式，可以参考 [94.二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/) 的题解

### 复杂度

- 时空复杂度分析与第一种方法一致
