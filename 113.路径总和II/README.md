# [113. 路径总和II](https://leetcode-cn.com/problems/path-sum-ii/solution/lu-jing-zong-he-ii-by-leetcode-solution/)
`BFS` `DFS`

## DFS

### 解题思路
对二叉树前序遍历的过程中，利用两个栈记录遍历过的节点和对应的路径，当遇到叶子节点的时候，判断路径和是否等于目标值
1. 模拟二叉树前序遍历，根节点入栈
2. 弹出栈顶，判断是否为叶子节点，如果是，再判断路径和是否等于目标值
3. 根据栈后进先出的特性，让右子节点入栈，并记录路径
4. 左子节点入栈，并记录路径
5. 循环执行上述步骤，直至栈被清空，说明所有节点都访问完毕

### DFS 转化为 BFS 
- 使用队列记录遍历过的节点和对应的路径
- 模拟二叉树层序遍历，根节点入栈
- 出队，判断是否为叶子节点，如果是，再判断路径和是否等于目标值
- 根据队列先进先出的特性，让左子节点入栈，并记录路径
- 右子节点入栈，并记录路径
- 循环执行上述步骤，直至队列被清空，说明所有节点都访问完毕

### [复杂度](https://stackoverflow.com/questions/24601111/whats-time-complexity-of-this-algorithm-for-finding-all-path-sum)
- **时间复杂度**：O(NlogN) = O(N) 前序遍历二叉树 * O(logN) 拷贝用于记录路径的栈或队列，为树的高度
- **空间复杂度**：O(NlogN) = O(N) 从根节点到叶子节点的路径数据不大于 N/2  * O(logN) 对于平衡二叉树，每条路径的节点个数为最大深度，即树的高度

## 递归⭐️
使用递归方式实质上就是将`DFS`转换成递归版本，枚举每一条从根节点到叶子节点其实就是枚举左（右）子树的所有路径，再将路径加上根节点
1. 从根节点开始记录路径
2. 判断根节点是否为叶子节点，并判断路径总和与目标是否相等
3. 遍历左（右）子树，目标值更新为 `targetSum - root.val`
4. 遍历到底部，舍弃叶子节点，重复上述步骤访问父节点的其他子节点

### 复杂度
- 时空复杂度的分析思路与上述方法相同
