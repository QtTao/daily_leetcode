# [207. 课程表](https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/)

`拓扑排序` `深度优先搜索` `广度优先搜索`

## [BFS](https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/)

拓扑排序是指给定一个 n 个结点的有向图 G，给出它的结点编号的排列，它满足对于 G 的任意一条有向边 `(u, v)` , u 都在出现在 v 的前面，由此可以得出两个结论

- 如果图 G 存在环，那么不存在拓扑排序，这是因为它不满足任意一条有向边，排序顺序唯一的情况
- 如果图 G 是有向无环图，那么它的拓扑排序可能不止一种，比如图 G 只有 n 个结点，没有任何边，那么任意一种排序都可以作为拓扑排列

根据题意，可以课程表问题转化成求拓扑排序的问题

- 每个课程看成图 G 的一个结点
- 想要学习课程 B 之前必须完成课程 A，在图 G 就是一条由 A 指向 B 的有向边，这样在拓扑排序中，A 一定出现在 B 的前面

在实现 BFS 拓扑排序时，除了保存入度为 0 的队列外，还需要两个辅助数据结构

- 邻接表：存储每个课程的后续课程集合，即某一个结点的所有有向边，作用是通过结点的索引，能够快速找到这个结点的后继结点
- 入度数组：存储每个课程有多少个先修课程，作用是通过结点的索引，能够得到指向这个结点的结点个数

### 解题思路

1. 初始化邻接表 `edges` 和入度数组 `indegrees`，遍历课程关系 `prerequisites`，统计每个课程的入度和它的所有后续课程
2. 在拓扑排序之前，现将所有入度为 0 的课程加入队列 `queue` 中
3. 遍历队列 `queue`，取出队首课程，将这个课程加入结果集中，并且将这个课程的所有后续课程的入度减 1，在减 1 以后，如果入度变为 0，那么将这个课程加入 `queue` 中
4. 当队列 `queue` 为空，检查结果集中的课程数是否跟 `numCourses` 相等即可，如果存在环形依赖，肯定有部分课程的入度永远不为 0，所以结果集中的课程数会小于 `numCourses`

### 复杂度

- 时间复杂度：O(M + N) 其中 M 是课程数量，N 是课程之间的关系数量，即 M 是图 G 的结点数，N 是图 G 的有向边数量
- 空间复杂度：O(M + N) 需要 O(M) 的队列空间，和 O(M + N) 的邻接表空间

## DFS

使用深度优先搜索来完成拓扑排序，可以考虑用栈来存储已经搜索完成的结点。对于有向图 G 的一个结点 u，如果它的所有相邻结点都搜索完成，那么在递归回溯到结点 u 时，u 本身也会变成一个已经搜索完成的结点，而这里的相邻结点是指从 u 出发通过一条有向边可以到达的所有结点。假设当前搜索的结点是
u，如果它的所有相邻结点已经搜索完成，那么这些结点都会保存在栈中，此时可以将结点 u 入栈，这样从栈顶到栈底就是这个有向图 G 对于结点 u 而言的拓扑排序结果

在深度优先搜索中，对于图中的任意一个结点，有三种状态：

- 未搜索：还没搜索到这个结点，标记为 0
- 搜索中：正在搜索这个结点和它的相邻结点，但还没回溯到该结点，即尚未入栈，还有其他相邻结点没有完成搜索，标记为 1
- 已完成：该结点和它的相邻结点都已经搜索过，并入栈，满足拓扑排序的要求，标记为 2

### 解题思路

1. 初始化邻接表 `edges` 和状态数组 `visited`，其中状态数组全部为 0
2. 遍历 `prerequisites`，统计每个课程的邻接课程
3. 取任意一个课程，对其进行深度优先搜索，假设当前搜索的课程为 u，将其标记为 1，在递归遍历相邻课程 v 时
    - 如果 v 的状态为未搜索，那么标记它的状态 1，表示搜索中
    - 如果 v 的状态为搜索中，说明图中存在环形依赖，因此不存在拓扑排序
    - 如果 v 的状态为已完成，说明 v 和它的所有相邻课程都已经搜索完成，且都已入栈，此时栈中的顺序满足拓扑排序
    - 当 u 的所有相邻课程都已标记为已完成，将 u 入栈，并标记为已完成
4. 当图中所有课程都标记为已完成，说明课程遍历完成，从栈顶到栈底就是其中一种拓扑排序，否则图中存在环形依赖，不存在拓扑排序

### 复杂度

- 时间复杂度：O(M + N) 其中 M 为课程数，N 为课程之间的关系数
- 空间复杂度：O(M + N) 首先需要 O(M + N) 的空间将课程表处理成邻接表的形式，然后在深度优先搜索中需要 O(N) 的递归栈空间
