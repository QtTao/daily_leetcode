# [210. 课程表II](https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/)

`拓扑排序` `深度优先搜索` `广度优先搜索`

## [BFS](https://leetcode-cn.com/problems/course-schedule-ii/solution/tuo-bu-pai-xu-shen-du-you-xian-bian-li-python-dai-/)

[图有两种表示方法](https://www.cnblogs.com/liushang0419/archive/2011/05/06/2039386.html)

- 邻接矩阵：若 `(vi, vj)` 是图 G 的一条边，`G[i][j] = 1`，否则 `G[i][j] = 0`
- 邻接表：对于图的每个结点，用一个单向链表列出从该结点出发的所有弧，链表中每个元素对应与一条出弧

[图有两种遍历方式](https://qttao.github.io/2017/02/01/graph/)

- 深度优先搜索
- 广度优先搜索

拓扑排序是专门应用于有向图的算法，它的排序结果不唯一，通过拓扑排序还能检测有向图中是否存在环（拓展：无向图中检测是否有环，使用的数据结构是并查集）

### 解题思路

1. 在开始排序之前，遍历 `prerequisites` 初始化邻接表和入度数组，分别用于每门课程的所有后续课程和先修课程数
2. 将入度为 0 的课程放入队列 `queue`，即可以从这些没有先修课程的课程开始排序
3. 只要 `queue`，从队首取出入度为 0 的课程，并将它输出到结果集中，然后将这个课程的所有课程入度减 1，如果其中某个课程入度为 0，那就将它入队
4. 这里使用队列的原因是为了**确保每门课程的先修课程都排在该课程的前面，并且可以完成所有课程**
5. 完成 `queue` 的遍历，如果排序结果的长度不等于课程数，说明课程存在循环依赖，否则直接输出排序结果

### 复杂度

- 时间复杂度：O(M + N) 这里 M 是图的边数，N 是图的结点数，初始化入度数组和邻接表需要检查每一个结点和每条边，所以复杂度为 O(M + N)
- 空间复杂度：O(N) 队列在最长的情况下需要存储所有结点，即 O(N)

## DFS

深度优先遍历的做法是当前搜索到的课程 u，同时将它的所有后续课程都进行搜索，并用一个栈来存储所有已经搜索过的课程，那么从栈顶到栈底看，课程 u 出现在所有它的相邻课程的前面，这样就满足拓扑排序的要求了。如果我们图中每个结点都进行深度优先搜索，最终从栈顶到栈底的序列就是一种拓扑排序

在深度优先搜索的过程中，对于图中任意一个课程，它都有三种状态，即：

- 未搜索：尚未开始搜索的课程
- 搜索中：正在搜索它的后续课程，但还没回溯到该课程，即还没入栈，它的后续课程还没完成搜索
- 已完成：包括当前课程和它的后续课程在内所有课程已经搜索完成，并入栈，比起当前课程，它的后续课程都出现栈更底部的位置，满足拓扑排序的要求

### 解题思路

1. 初始化邻接表和状态数组，其中状态有三种：分别是未搜索 0，搜索中 1 和已完成 2
2. 利用 `prerequisites` 获取每门课程的所有后续课程
3. 针对每门未搜索的课程，进行深度优先搜索
    - 首先将当前课程状态标记为搜索中 1
    - 深度遍历它的所有后续课程
        - 如果状态为未搜索 0，那么继续遍历它的后续课程，直至到达底部或者存在环
        - 如果状态为搜索中 1，即表明课程中存在循环依赖，没有拓扑排序结果
        - 如果状态为已完成 2，说明该课程此前已加入排序结果中，无需搜索
    - 当完成所有后续课程的遍历后，将当前课程状态标记为已完成 2
    - 最后将当前课程入栈
4. **由于最先入栈的课程肯定是没有任何后续课程，而越后入栈的入度越少，后续课程也较多，因为在输出排序结果需要将数组反转**

### 复杂度

- 时间复杂度：O(M + N) 其中 M 为课程数，即图的结点数，N 为课程之间的关系数，即图的边数
- 空间复杂度：O(M + N) 首先需要 O(M + N) 的空间将课程表处理成邻接表的形式，然后在深度优先搜索中需要 O(N) 的递归栈空间
