# [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/)

`双指针`

## 单指针

考虑对数组进行两次扫描，第一遍将 0 交换至数组头部，第二遍将 1 交换至 0 的后面，此时所有的 2 都会出现在数组的尾部，这样就能完成排序

### 解题思路

1. 初始化指针指向数组头部
2. 第一遍扫描后将 0 交换至数组头部，指针随着交换操作往前移动
3. 从指针的位置开始扫描，将 1 交换至 0 的后面，完成排序

### 复杂度

- 时间复杂度：O(N) 两次扫描
- 空间复杂度：O(1)

## 前后双指针

单指针是对 0 和 1 元素分别进行交换，利用双指针用来交换 0 和 1 可以通过一次遍历完成排序

### 解题思路

1. 初始化 `p0` 和 `p1` 分别指向数组头部，其中 `p0` 用于交换 0，而 `p1` 用于交换 1
2. 由于 0 需要排在 1 的前面，所以先进行 1 的交换，一次交换将 1 交换至数组头部，然后 `p1` 向前移动，等待下次交换
3. 如果遇到 0，那么将 0 交换至数组头部，如果此前进行了 1 的交换，1 已经位于数组头部，这时再进行 0 的交换，一定会将 1 交换出现，所以需要将当前元素即 1 与 `p1` 对应元素交换回来
4. 如果遇到 0，需要将 `p0` 和 `p1` 指针向前移动，这是因为
   - 如果在 `p0` 和 `p1` 都发生了元素交换，那么两指针必须向前移动
   - 如果只有 `p0` 指针位置发生了元素交换，`p0` 指针向前移动，同时**由于 1 必须放在 0 的后面，所以 `p1` 指针也需要向前移动**

### 复杂度

- 时间复杂度：O(N) 一次扫描
- 空间复杂度：O(1)

## 头尾双指针

前后双指针用于 0 和 1 的交换操作，而头尾双指针用于 0 和 2 的交换操作，即将 0 交换至数组头部，2 交换至数组尾部

### 解题思路

1. 初始化双指针，分别指向数组头部 `left` 和尾部 `right`，另外初始化下标 `idx`，用于遍历数组
2. 一旦遇到 2，将它交换至数组尾部，同时尾指针 `right` 向后移动，直至 `idx` 对应元素不再是 2
3. 此时如果 `idx` 对应的是 0，将其交换至数组头部，同时头指针 `left` 向前移动
4. 先处理 2 再处理 0 的是因为将 2 交换至数组尾部，`idx` 有可能指向 0，如果直接 `idx + 1` 开始遍历下一个元素，就会出现错误的结果
5. 当完成对 2 和 0 的交换操作，可以认为对 `idx` 的所有情况都已经处理完了，开始遍历下一个元素

### 复杂度

- 时间复杂度：O(N) 一次扫描
- 空间复杂度：O(1)

## 直接赋值

前面的方法都需要对元素进行交换，包括

- 首先将 0 交换至数组头部，然后将 1 交换至 0 的后面
- 一次遍历中先将 1 交换至数组头部，再将 0 交换至数组头部
- 一次遍历中先将 2 交换至数组尾部，再将 0 交换至数组头部

直接赋值就是经过一次遍历，数组区间 `[0, p0]` 逐一赋值为 0，`[p0 + 1, p1]` 逐一赋值为 1

### 解题思路

1. 初始化 `p0` 和 `p1` 分别记录 0 的出现次数，和 0 或 1 的出现次数，其中 `p0` 也可以代表 0 在排序后数组的下标
2. 遍历数组，使用临时变量 `num` 保存下标对应的元素，然后将当前下标默认设置为 2
3. 当 `nums` 是 0 或 1，将 `p1` 对应元素设为 1，同时 `p1` 指针向前移动
4. 经过步骤 3 的处理后，当 `num` 是 0，将 `p0` 对应元素设为 0，同时 `p0` 指针向前移动，由于步骤 3 有可能会将本来为 0 错误设置为 1，这一步将它重设为 0，这样**经过多轮循环后，数组中 `[0, p0]` 区间一定是 0，而数组中 `[p0 + 1, p]` 区间是 1**

### 复杂度

- 时间复杂度：O(N) 一次扫描
- 空间复杂度：O(1)
