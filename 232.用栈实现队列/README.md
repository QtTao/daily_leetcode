# [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/)

## 双栈（输入栈 + 输出栈）

### 解题思路

初始化双栈 `stack1` 为输入栈，`stack2` 为输出栈，`front` 为 `stack1` 的"队首"

- 入队：新元素总是压入 `stack1`，同时将压入第一个元素作为 `stack1` 的"队首"（`front`）
- 出队：根据栈的后进先出的特性，`stack1` 中第一个压入元素在底部，所以需要将 `stack1` 的元素全部弹出，然后压入输出栈 `stack2`，这样原来在 `stack1` 的底部的元素变成 `stack2` 的栈顶，这时可以弹出 `stack2` 的栈顶元素即"队首"，当 `stack2` 为空，从 `stack1`
  转移元素即可
- 判断空：检查 `stack1` 和 `stack2` 是否都为空
- 访问队首元素：当 `stack2` 非空，`stack2` 的栈顶就是队首，否则就是 `front`

### 复杂度

- 时间复杂度：O(1)
    - 入队：向栈压入元素时间复杂度为 O(1)
    - 出队：摊还复杂度 O(1)，最坏情况是 `stack2` 为空，需要从 `stack1` 弹出元素然后压入 `stack2`，时间复杂度为 O(N)，但当 `stack2` 非空，只有 O(1) 的时间复杂度
    - 判断空：O(1)
    - 访问队首元素：O(1)
- 空间复杂度：除了入队需要 O(N) 的空间复杂度，其他操作都是 O(1)

### 摊还分析

- 摊还分析的核心在于，最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价
- 出队操作最多可以执行的次数跟它之前执行过入队操作的次数有关。虽然一次出队操作代价可能很大，但是每 n 次入队才能产生这么一次代价为 n 的出队操作
- 所有操作的总时间复杂度为：n (所有的入队操作产生） + 2n (第一次出队操作产生） + n - 1 (剩下的出队操作产生）， 所以实际时间复杂度为 O(2n)。于是我们可以得到每次操作的平均时间复杂度为 O(2n/2n)=O(1)
