# [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao-by-leetcod/)

`回溯` `哈希表`

## 回溯 + 哈希表

回溯算法是先按照链表的顺序遍历，每遇到一个新的结点，就创建一个全新的结点，并记录下来，然后通过回溯的方式处理 `random` 指针对应的结点，这样就可以通过此前的记录快速找到对应的结点

### 解题思路

1. 按照深度优先遍历链表
    - 当前结点为空结点，直接返回 `None`
    - 当前结点已访问，从哈希表中返回对应的新结点
    - 当前结点没访问过，创建对应的新结点，并加入哈希表中
2. 拷贝当前结点的下一个结点来更新新结点的 `next` 指针
3. `random` 指针同理

### 复杂度

- 时间复杂度：O(N) 其中 N 是链表结点数
- 空间复杂度：O(N) 递归调用栈的深度，和记录拷贝后的新结点的空间

## 链表遍历 + 哈希表

处理 `random` 指针的关键在于使用哈希表记录访问过的结点，考虑在链表遍历的过程，建立新旧结点映射关系的哈希表

### 解题思路

1. 构造获取深拷贝结点的函数 `get_cloned_node`
    - 当前结点为空结点，直接返回 `None`
    - 当前结点已访问，从哈希表中返回对应的新结点
    - 当前结点没访问过，创建对应的新结点，同时加入哈希表中
2. 遍历链表
    - 若 `head` 为空结点，直接返回 `None`
    - 初始化 `dummy` 结点，`next` 指针指向利用 `get_cloned_node(head)` 生成的结点，同时该结点已经加入哈希表中，方便 `random` 指针关联
    - 通过 `head` 指针遍历链表时，更新新结点 `new_head` 的 `next` 和 `random` 指针，然后将 `head` 和 `new_head` 向前移动，直至到达原始链表的尾部

### 复杂度

- 时间复杂度：O(N) 其中 N 是链表结点数
- 空间复杂度：O(N) 保存新旧结点映射关系的哈希表所需的空间

## 链表遍历（空间优化）

考虑不使用哈希表保存新旧结点的映射关系，可以利用原始链表结点的先后顺序，在两个结点之间插入新的结点，构造一条新旧结点交错的链表，如原始链表为 `A -> B -> C`，加入新结点后的链表为 `A -> A' -> B -> B' -> C -> C'`，最后再将 `A' -> B' -> C'` 拆分出来

### 解题思路

1. 遍历原始链表，并深拷贝每一个结点，将拷贝的即诶安放在原来结点的旁边，构造一个新旧结点交错的链表，即 `A -> A' -> B -> B' -> C -> C'`，其中原始结点的 `next` 指针指向都是新创造出来的结点
    - `new_node.next = old_node.next`
    - `old_node.next = new_node`
2. 遍历新旧结点交错的链表，并用旧结点的 `random` 指针去更新对应新结点的 `random` 指针
    - 若旧结点的 `random` 指针指向 `None`，那么新结点也指向 `None`
    - 否则，新结点的 `random` 指针指向旧结点的 `random` 指针指向的结点的下一个结点，即 `new_node.random = old_node.random.next`
3. 完成步骤 2 后，`next` 和 `random` 指针已完成复制，这时需要将交错链表复原
    - 恢复原始链表 `old_node.next = old_node.next.next`
    - 旧结点指针向前移动 `old_node = old_node.next`
    - 从交错链表中提取新链表 `new_node.next = new_node.next.next`
    - 新结点指针向前移动 `new_node = new_node.next`

### 复杂度

- 时间复杂度：O(N) 其中 N 是链表结点数
- 空间复杂度：O(1) 在原始链表上操作，没有使用额外的空间
