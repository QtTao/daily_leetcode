# [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)

`二分查找`

## 二分查找

为了实现 O(log(N1 + N2)) 的时间复杂度，通常采用二分查找法。假设两个有序数组的长度分别为 n1 和 n2

- 当 `n1 + n2` 是奇数，那么中位数就是第 `(n1 + n2 + 1) / 2` 个元素，
- 当 `n1 + n2` 是偶数，中位数是第 `(n1 + n2) / 2` 个数和第 `(n1 + n2) / 2 + 1` 个数的平均值，这样求中位数的问题就可以转换为求两个有序数组的第 k 个数，其中 k 是 `(n1 + n2 + 1) / 2`，`(n1 + n2) / 2` 或 `(n1 + n2) / 2 + 1`

### 解题思路

1. 考虑每次迭代比较 `nums1[k / 2 - 1]` 和 `nums2[k / 2 - 1]` 的大小，这是因为两者的较小值最多只会有 k - 2 个元素比它小，所以肯定不是第 k 小的数，可以直接排序
    - 如果 `nums1[k / 2 - 1] < nums2[k / 2 - 1]`，则比 `nums1[k / 2 - 1]` 小的数最多只有 `nums1` 的前 `k / 2 - 1` 个数和  `nums2` 的前 `k / 2 - 1` 个数，即最多只有 k - 2 个数比它小，所以 `nums1[k / 2 - 1]`
      肯定不是第 k 个数，故全部排序
    - 如果 `nums1[k / 2 - 1] > nums2[k / 2 - 1]`，可以排序 `nums2[0]` 到 `nums2[k / 2 - 1]`
    - 如果 `nums1[k / 2 - 1 = nums2[k / 2 - 1]`，直接归入第一种情况
2. 排除 `k / 2` 个元素后，其中一个数组的查找范围缩小了一半，然后在排除后的数组上继续步骤 1 二分查找法，并且每次根据排除元素的个数，重新计算 k 的值（因为排除的数都是不大于第 k 小的数），有三种边界情况需要特殊处理：
    - 如果每次定位 `k / 2 - 1` 时有可能会出现在某个数组是越界的情况，这时可以选取数组最后一个元素，即 `min(k / 2 - 1, n1 - 1)`
    - 当其中一个数组的下标移动到末尾时，说明该数组的所有元素已被排除，那么可以直接返回另一个数组的第 `n1 or n2 + k` 个数
    - 当 `k = 1` 时，返回数组第一个元素最小值即可

![步骤1](https://i.loli.net/2021/04/24/BRqETix71PzQoHI.png)

### 复杂度

- 时间复杂度：O(log(N1 + N2)) 每一轮循环都会减少其中一个数组元素的一半
- 空间复杂度：O(1)

## [二分查找进阶版](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)

中位数的作用：将一个集合划分为两个长度相等的子集，其中一个子集的元素总是大于另一个子集的元素

为了更好地说明，将数组 A 和数组 B 的左半部分放入一个集合中，将剩余的元素放入另一个集合中，其中数组 A 长度为 n1，划分位置是 i，数组 B 的长度为 n2，划分位置是 j

```markdown
        left side        |        right side               

A[0], A[1],..., A[i - 1] | A[i], A[i + 1],..., A[n1 - 1]
B[0], B[1],..., B[i - 1] | B[i], B[i + 1],..., B[n2 - 1]
```

要使以下这些条件成立

- 当 `n1 + n2` 为偶数，len(left side) = len(right side)，max(left side) <= min(right side)，median = [max(left side) + min(right side)] / 2
- 当 `n1 + n2` 为奇数，len(left side) = len(right side) + 1，max(left side) <= min(right side)，median = max(left side)

需要保证

- 当 `n1 + n2` 为偶数，`i + j = m - i + n - j`
- 当 `n1 + n2` 为奇数，`i + j = m - j + n - j + 1`，可与第一种情况合并为 `j = (m + n + 1) / 2`
- 规定 `n1 <= n2`，那么对于任意 `i ∈ [0, n1]`，都有 `j = (m + n + 1) / 2 ∈ [0, n2]`，换言之，只需要 `[0, n1]` 这个区间中进行二分查找，找到满足条件的 i 即可
- **`B[j - 1] <= A[i]` 以及 `A[i - 1] <= B[i]`，即左半部分的最大值小于等于右半部分的最小值**，证明这个条件等价于在 `i ∈ [0, n1]` 中找到最大的 i，使得 `A[i - 1] <= B[i]`？
- 在不影响最值判断的前提下，规定 `i = 0`，`i = n1`，`j = 0`，`j = n2` 这些边界情况为负无穷和正无穷，这样就不用特殊处理这些临界条件

### 解题思路

1. 初始化左右指针，分别指向较短数组的起始下标 `left` 和结束下标 `right`
2. i 为 `left` 和 `right` 的中间位置，而按照上述分析过程，`j = (n1 + n2 + 1) / 2 - i`
3. 找出 `nums1[i - 1]`，`nums1[i]`，`nums2[j - 1]`，`nums2[j]`
    - **当 `nums1i - 1] <= nums2[j]`**，取 `nums1[i - 1]` 和 `nums2[j - 1]` 的最大值和 `nums1[i]` 和 `nums2[j]` 的最小值，`left` 向前移动，逼近 i 的最大值
    - 否则，说明 `nums1[i - 1]` 较大，需要减少 i 值，所以 `right` 向后移动，进一步缩小查找范围
4. 当 `left > right`，结束查找（这里注意 `left = right` 也需要进行一次查找）
    - 当 `n1 + n2` 为偶数，中位数是左半部分最大值和右半部分最小值的平均值
    - 当 `n1 + n2` 为奇数，中位数是左半部分的最大值

### 复杂度

- 时间复杂度：O(log(min(N1, N2))) 每一轮循环减少较短数组元素的一半
- 空间复杂度：O(1)
