# [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/)

`哈希表`

## 哈希表

如果不考虑 O(1) 的空间复杂度，可以将数组所有元素放入哈希表，然后从 1 依次枚举正整数，并判断其是否在哈希表中。为了满足 O(1) 的空间复杂度，可以利用原始数组来模拟哈希表的作用。实际上，对于长度为 N 的数组，没有出现的最小正整数只能在 `[1, N + 1]` 中，因为如果所有元素都在 `[1, N]`
中，那么最小正整数就是 `N + 1`，否则必然在 `[1, N]` 内。基于这个结论，可以考虑利用数组的下标范围 `[0, N - 1]` 与数组元素通过哈希函数关联在一起，对于每一个元素，

- 将所有不是正数设为 `N + 1`，此步骤后数组全为正数
- 如果它是不在 `[1, N]` 的正数，保留原值
- 如果它是在 `[1, N]` 的正数 `x`，将下标为 `x - 1` 的元素设置为负数，但 `x` 有可能已经被标记过了，所以下标应取绝对值 `|x| - 1`

### 解题思路

1. 遍历数组，将所有不是正数设为 `N + 1`，避免与 `[1, N]` 范围的数字冲突
2. 再次遍历数组
    - 如果元素 `x` ∈ `[1, N]`，将下标 `|x| - 1` 对应的元素设为 `-|x|`，这里相当于标记 `[1, N]` 的其中一个位置
    - 如果元素 `x` ∉ `[1, N]`，保留原值不变
3. 第三次遍历数组，寻找第一个大于零的下标，如果没有这个下标，说明数组所有元素都在 `[1, N]` 中，那么缺失的最小正整数就是 `N + 1`

### 复杂度

- 时间复杂度：O(N) N 为数组长度，进行了三次遍历
- 空间复杂度：O(1)

## 交换元素

假设原始数组为 `[3, 4, -1, 1]`，如果将数组的元素重新排列成 `[1, -1, 3, 4]`，该数组的下标为 2 没有跟元素值对应，所以缺失的最小正整数就是 2，这时寻找最小的缺失正整数的前提就是要将数组通过元素交换进行重新排列

### 解题思路

1. 遍历数组，当元素位于 `[1, N]` 的范围内，且 `nums[idx]` 不等于 `nums[nums[idx] - 1]`，将 `nums[idx]` 和 `nums[nums[idx] - 1]` 进行交换
    - 以 `[3, 4, -1, 1]` 为例，第一次遍历交换的结果 `[-1, 4, 3, 1]`，结束 while 循环，第二遍历交换的结果是 `[1, -1, 3, 4]`，随后由于 3 和 4 已位于正确的位置，结束数组遍历
2. 寻找第一个下标值 + 1 与 `nums[idx]` 不相等的情况，返回下标值 + 1，否则所有元素都在正确位置上，返回 `N + 1`

### 复杂度

- 时间复杂度：O(N) N 为数组长度
- 空间复杂度：O(1)
