# [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/)

`双指针` `递归`

## 递归

使用递归可以实现反转链表，当然也可以实现对链表进行逆序遍历，让指针先到达链表的尾结点，利用递归的特性从后往前进行比较，特别需要增加一个递归函数外的指针，负责从前往后遍历链表

### 解题思路

1. 初始化递归外的链表指针 `self.head` 指向链表头部
2. 递归检查链表结点是否跟 `self.head.val` 相等，因为递归调用栈会首先弹出链表尾结点，与 `self.head.val` 进行比较
   - 如果相等，递归外指针向前移动
   - 否则说明不是回文链表，返回 `False`

### 复杂度

- 时间复杂度：O(N) N 为链表长度
- 空间复杂度：O(N) 递归调用栈深度，为链表长度

## 快慢指针

为了实现 O(1) 的空间复杂度，只能考虑在原始链表上操作。首先将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较，比较完成后将链表恢复原样

### 解题思路

1. 根据 [876.链表的中间结点](../876.链表的中间结点/solution.py) 快慢指针发找到前半部分链表的尾结点
2. 根据 206.反转链表 反转后半部分的链表
3. 同时遍历两个链表，判断是否回文，由于后半部分肯定比前半部分要短，所以当后半部分到达尾部后，结束遍历
4. 恢复链表原样
5. 返回结果

### 复杂度

- 时间复杂度：O(N) N 为链表的长度
- 空间复杂度：O(1) 无论是快慢指针，还是链表反转，使用都是常数空间
