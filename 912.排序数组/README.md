# [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/)

`快速排序` `堆排序` `归并排序`

## 快速排序

快速排序的基本思想是选取基准元素，依次将剩余元素中小于该基准元素的值放在左边，大于等于该基准元素的值放在右边；然后按照同样的方法递归处理基准元素的前半部分和后半部分，直至各个子序列只剩余一个元素时，排序完成

### 解题思路

1. 首先选取一个基准元素 pivot，选取方法有第一个元素，中间元素和随机选择，这里采用随机选择方法 `random.randint(low, high)`
2. 创建 `partition` 分区函数将小于等于 pivot 的值集中到数组的左边 `left_side`，那么大于 pivot 就会自然集中到数组的有右边 `right_side`，分区函数将数组分为三份：`left_side, pivot, right_side`
3. 然后分别对 `left_side` 和 `right_side` 进行独立排序，对于左半部分的数组，应用 `partition` 函数得到左边的 pivot，同时将 `left_side` 也分成三个部分。`right_side` 也做类似的处理
4. 重复上述过程，递归将左右两边都排好序后，直至上界索引小于下界索引 `high < low`，终止递归，完成数组排序

### 复杂度

- 时间复杂度：O(NlogN) 平均情况下，快速排序的时间复杂度为 O(NlogN)，最差的情况是原始数组已经有序，快速排序会退化成冒泡排序，时间复杂度为 O(N^2)
- 空间复杂度：O(logN)

## 堆排序

堆排序的思想就是先将待排序的序列建成大根堆，即每个父结点的元素大于等于它的子结点，此时整个序列的最大值为堆顶元素，然后将其与末尾元素交换，再调整堆顶元素使得剩下的元素仍为大根堆，重复上述操作即可得到排序数组

### 解题思路

待补充

### 复杂度

- 时间复杂度：O(NlogN) 每次调整为大根堆的时间复杂度为 O(logN)，总共需要 N - 1 次调整
- 空间复杂度：O(1) 无额外空间

## 归并排序

归并排序是利用分治思想对数组进行排序。对一个长为 n 的数组，将其分解成两个长度为 n / 2 的子序列，每次先递归调用函数使子序列有序，然后再线性合并两个有序的子序列使得整个数组有序

### 解题思路

1. 定义 `merge_sort(nums, left, right)` 函数对 nums 数组中 `[left, right]` 部分进行排序
    - 递归调用 `merge_sort(nums, left, mid)` 对 nums 数组中 `[left, mid]` 部分进行排序
    - 递归调用 `merge_sort(nums, mid + 1, right)` 对 nums 数组中 `[mid + 1, right]` 部分进行排序
    - 此时 nums 数组中 `[left, mid]` 和 `[mid + 1, right]` 两个区间已经有序，需对两个区间进行线性合并
        - 首先维护两个指针 i 和 j 表当前考虑到 `[left, mid]` 里第 i 个位置和 `[mid + 1, right]` 的第 j 个位置
        - 当 `nums[i] <= nums[j]`，将 `nums[i]` 加入临时数组 tmp 中，并让 `i += 1`，即指针后移一位，否则将 `nums[j]` 放入临时数组中，并让 `j += 1`
        - 如果某一个指针已经移到区间的末尾，那么就把另一个区间里的数按顺序加入临时数组 tmp 即可
2. 完成排序，返回数组

### 复杂度

- 时间复杂度：O(NlogN) 归并排序每次将当前待排序数组折半成两个子序列进行递归处理，然后再合并两个有序子序列，故时间复杂度为 O(NlogN)
- 空间复杂度：O(N) 需要额外的 O(N) 的临时数组 tmp，另外，归并排序中递归调用栈空间为 O(logN)，故空间复杂度为 O(N + logN) = O(N) 
