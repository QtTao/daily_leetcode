# [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/)

`动态规划` `通项公式`

## 动态规划

### 解题思路

假设 `T(n)` 为爬第 `n` 阶楼梯的方法数量，那么它由 `T(n - 1)` 和 `T(n - 2)` 两部分组成

1. `T(n - 1)` 爬上 `n - 1` 阶楼梯的方法数量，因为它再爬一阶就能到达第 `n` 阶
2. `T(n - 2)` 爬上 `n - 2` 阶楼梯的方法数量，因为它再爬两阶就能到达第 `n` 阶
3. 递推公式 `T(n) = T(n - 1) + T(n - 2)`
4. 初始化 `T(1) = 1 T(2) = 2`

### 复杂度

- 时间复杂度：O(N) 循环执行 N 次，适用于 `n` 比较小的情况
- 空间复杂度：O(1) 常量空间

## [矩阵快速幂](https://leetcode-cn.com/circle/article/8uRHgu/#通项公式计算overflowerror)

### 解题思路

动态规划方法适用于 `n` 比较小的情况，当 `n` 变大之后，O(N) 的时间复杂度就会变得难以应付，故引入矩阵快速幂来处理

1. `[[1, 1], [1, 0]][T(n), T(n - 1)] = [T(n + 1), T(n)]`
2. 由第一点可以得出 `[T(n + 1), T(n)] = [[1, 1], [1, 0]]^n[T(1), T(0)]` 其中 `[[1, 1], [1, 0]]^n` 就是需要快速计算的矩阵幂

### 复杂度

- 时间复杂度：O(logN) 分奇偶处理，矩阵快速幂的时间复杂度
- 空间复杂度：O(1) 常量空间

## [斐波那契数列通项公式](https://www.zhihu.com/question/28062458)

### 解题思路

通项公式：`T(n) = {[(1 + sqrt(5)) / 2]^n - (1 - sqrt(5)) / 2]^n} / sqrt(5)`

### 复杂度

- 时间复杂度：O(1) Python 的 `math.pow` 底层调用 C 库的 `pow`，即 `2^(y*log2(x))`，时间复杂度为 O(1)
- 空间复杂度：O(1) 常量空间
