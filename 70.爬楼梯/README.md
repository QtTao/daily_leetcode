# [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/)

`动态规划` `通项公式`

## 动态规划

### 解题思路

假设 `T(n)` 为爬第 `n` 阶楼梯的方法数量，那么它由 `T(n - 1)` 和 `T(n - 2)` 两部分组成

1. `T(n - 1)` 爬上 `n - 1` 阶楼梯的方法数量，因为它再爬一阶就能到达第 `n` 阶
2. `T(n - 2)` 爬上 `n - 2` 阶楼梯的方法数量，因为它再爬两阶就能到达第 `n` 阶
3. 递推公式 `T(n) = T(n - 1) + T(n - 2)`
4. 初始化 `T(1) = 1 T(2) = 2`

### 复杂度

- 时间复杂度：O(N) 循环执行 N 次，适用于 `n` 比较小的情况
- 空间复杂度：O(1) 常量空间

## [矩阵快速幂](https://leetcode-cn.com/circle/article/8uRHgu/#通项公式计算overflowerror)

### 解题思路

动态规划方法适用于 `n` 比较小的情况，当 `n` 变大之后，O(N) 的时间复杂度就会变得难以应付，故引入矩阵快速幂来处理

1. `[[1, 1], [1, 0]][T(n), T(n - 1)] = [T(n + 1), T(n)]`
2. 由第一点可以得出 `[T(n + 1), T(n)] = [[1, 1], [1, 0]]^n[T(1), T(0)]` 其中 `[[1, 1], [1, 0]]^n` 就是需要快速计算的矩阵幂

### 复杂度

- 时间复杂度：O(logN) 分奇偶处理，矩阵快速幂的时间复杂度
- 空间复杂度：O(1) 常量空间

## [斐波那契数列通项公式](https://www.zhihu.com/question/28062458)

### 解题思路

通项公式：`T(n) = {[(1 + sqrt(5)) / 2]^n - (1 - sqrt(5)) / 2]^n} / sqrt(5)`

### 复杂度

- 时间复杂度：O(1) Python 的 `math.pow` 底层调用 C 库的 `pow`，即 `2^(y*log2(x))`，时间复杂度为 O(1)
- 空间复杂度：O(1) 常量空间

## 问题扩展

有 `n` 阶楼梯，基于以下的条件，问有多少种爬法？

1. 每次可以爬 1 或 2 个台阶
2. **不能连续跳两个台阶**（新增限制条件）

### 解题思路

假设

1. 假设 `f(n)` 是爬到第 `n` 阶的方法数量
2. 假设 `g(n, 1)` 表示爬到第 `n` 阶并且最后一步只跨越一个台阶的方法数
3. 假设 `g(n, 2)` 表示爬到第 `n` 阶并且最后一步跨越两个台阶的方法数，
4. 那么 `f(n) = g(n, 1) + g(n, 2), g(n, 1) = f(n - 1), g(n, 2) = g(n -2, 1)`，其中 `g(n, 2) = g(n - 2, 1)` 可以理解为最后一步跨越两阶，那么上一步只能跨越一阶
5. 递推公式：`f(n) = g(n, 1) + g(n, 2) = f(n - 1) + g(x-2, 1) = f(n - 1) + f(x - 2 - 1) = f(n - 1) + f(n - 3)`

### 实现代码

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        """ 爬楼梯进阶 """
        if n == 1:
            return 1
        if n == 2:
            return 2
        dp, dp1, dp2, dp3 = 0, 1, 1, 2
        for _ in range(3, n + 1):
            dp1 = dp2
            dp2 = dp3
            dp3 = dp
            dp = dp1 + dp3
        return dp
```

### 复杂度

- 时空复杂度与第一种方法一致
