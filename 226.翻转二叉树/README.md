# [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode-solution/)

`递归` `DFS` `BFS`

## 递归

从根节点开始，递归遍历二叉树，并从叶节点开始翻转，如果当前遍历的节点的左右子树已经完成翻转，那么只需要交换左右子树的位置，即可完成整棵树的翻转

### 解题思路

1. 注意边界条件，当二叉树为空，直接返回 `None`
2. 递归翻转左子树，并返回左子树的根节点 `left`
3. 递归翻转右子树，并返回右子树的根节点 `right`
4. 完成步骤 2 和 3 说明左右子树已完成翻转，最后将两子树交换位置即可（后序遍历）

### 复杂度

- 时间复杂度：O(N) N 为二叉树节点数
- 空间复杂度：O(N) 递归调用栈深度，等于二叉树的高度，平均情况下为 O(logN)，最坏情况是链状二叉树，复杂度为 O(N)

## DFS 非递归

二叉树的遍历既可以使用递归，也能使用栈来实现

### 解题思路

1. 初始化栈，压入根节点 `root`
2. 将栈顶节点弹出，然后交换该节点的左右子树的位置
3. 如果右子树的根节点非空，先入栈
4. 如果左子树的根节点非空，后入栈，先出栈
5. 模拟二叉树前序遍历的过程，直至栈为空

### 复杂度

- 时间复杂度：O(N) N 为二叉树的节点数
- 空间复杂度：O(N) 显式调用栈，最坏情况是链状二叉树，需要存储所有节点


## BFS 层序遍历

在层序遍历的过程中，翻转每一个节点的左右节点

### 解题思路

1. 初始化队列，根节点 `root` 入队
2. 将队首节点出队，然后交换该节点的左右子树的位置
3. 如果左子树的根节点非空，先入队，先出队
4. 如果右子树的根节点非空，后入队
5. 模拟二叉树层序遍历的过程，直至队列为空

### 复杂度

- 时间复杂度：O(N) N 为二叉树的节点数
- 空间复杂度：O(N) 最坏情况是链状二叉树，需要队列存储所有节点
