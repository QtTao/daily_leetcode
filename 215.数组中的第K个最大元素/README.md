# [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)

`快速排序` `堆`

## 局部淘汰

### 解题思路

1. 随机从数组中选择 K 个元素创建容器
2. 定位容器中最小值所在的位置，以及对应的值
3. 遍历容器外的元素，如果外面的数字比容器内的最小值要大，那么替换掉最小
4. 遍历完毕，容器内就是最大的 K 个元素，其中的最小值就是第 K 个最大元素

### 复杂度

- 时间复杂度：O(NK) 其中 N 为原数组长度，K 为容器长度
- 空间复杂度：O(K) 保存 K 个最大元素的容器

## 基于快速排序的选择方法

根据题意，只需寻找第 K 个最大元素，如果直接采用快速排序对整个数组进行，时间复杂度较高（O(NlogN)），而且做了很多无用功，但是利用快速排序的思想，对原数组进行分解和调整，只要找到一个数字，它位于数组第 `n - K` 的位置（从 0 开始），在它左边的元素都小于等于它，在它右边的元素都大于等于它，那么这个数字就是第 K 个最大数

### 解题思路

1. 随机从数组中选择划分的索引 q，经过一轮快速排序后，位于 q 左边都小于等于 `nums[q]`，而位于 q 右边都大于等于 `nums[q]`
2. 如果划分的索引 q，正好位于 `n - K`，那么直接返回 `nums[q]`
3. 如果划分的索引 q 比 `n - k` 小，说明目标下标在右半部分，递归搜索右子区间 `[0, q - 1]`
4. 如果划分的索引 q 比 `n - k` 大，说明目标下标在左半部分，递归搜索左子区间 `[q + 1, n]`
5. 重复上述步骤，直至找到 `n - k` 的位置

**注意**：基于快速排序的选择方法需要将数组载入内存中，对数组内部进行调整，如果数组太大，可以考虑方法三或者将全部数据分成多份处理

### 复杂度

- 时间复杂度：O(N) 平均时间复杂度为线性的选择算法
- 空间复杂度：O(logN) 递归调用栈空间

## 最小堆

### 解题思路

1. 先用前 K 个元素创建一个最小堆（根节点为所有节点中最小的堆），主要用于替换方法一中的容器，利用最小堆的特点寻找最小值比遍历容器复杂度更低
2. 从第 K + 1 个元素开始扫描，与堆顶节点（最小值）比较，如果当前数字大于堆顶节点值，则替换堆顶节点，然后调整堆，保证堆内 K 个节点是当前最大 K 个元素
3. 遍历完所有数字后，堆中的 K 个元素即是 TopK，其中堆顶就是第 K 个最大元素

### 复杂度

- 时间复杂度：O(NlogK) N 为数组长度，K 为堆节点个数，每次调整堆的时间复杂度为 O(logK)
- 空间复杂度：O(K) 最小堆节点数

