# [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/)

`DFS` `双指针`

## 将链表转换为数组

由于链表不支持索引访问，无法直接找到中间结点，考虑将有序链表转换为有序数组，那么题目就变成了 [108. 将有序数组转换为二叉搜索树](../108.将有序数组转换为二叉搜索树/README.md)

### 解题思路

1. 将链表转换为数组
2. 参考 [108. 将有序数组转换为二叉搜索树](../108.将有序数组转换为二叉搜索树/solution.py) 将有序数组转换为二叉搜索树

### 复杂度

- 时间复杂度：O(N) N 为链表的结点数
- 空间复杂度：O(logN) 递归调用栈深度为二叉树的高度 logN

## 快慢指针

其实，将有序链表转换为二叉搜索树的关键第一步是确定根结点，同时要让根结点的左右子树的结点数尽可能接近，换言之就是要找出链表中的中间结点值作为根结点的值，寻找链表的中间结点的经典方法就是快慢指针法

### 解题思路

1. 通过快慢指针找到链表的中间结点，注意这里的 `left` 和 `right` 不再是索引，而是链表结点
    - 为了避免访问链表的前驱元素，设定左闭右开的关系，那么可以直接用 `[left, mid)` 和 `[mid.next, right)` 来表示左右子树对应的列表，并且初始化可以使用 `[head, None)` 来表示，其中 `None` 为空结点
2. 找出根结点后，分别利用左侧链表和右侧链表递归构建左右子树

### 复杂度

- 时间复杂度：O(NlogN) N 为链表的结点数
- 空间复杂度：O(logN)

## [模拟中序遍历](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/shou-hua-tu-jie-san-chong-jie-fa-jie-zhu-shu-zu-ku/)

由于二叉搜索数的中序遍历就是有序链表本身，可以通过模拟中序遍历的过程来构建二叉搜索树，为了满足高度平衡的条件，可以利用链表的长度来让左右子树的结点个数尽量接近

### 解题思路

1. 首先统计链表结点个数 `length`
2. 开始模拟中序遍历（直接遍历链表），先创建一个空的根结点，同时构建的它的左子树（先访问左子树）
3. 填充完左子树结点后，再填根结点，然后链表向前移动（再访问根结点）
4. 最后用链表剩余的结点填充根结点的右子树（最后访问右子树）
5. 注意当 `left > right`，返回空结点，用于连接叶结点

### 复杂度

- 时间复杂度：O(N) 统计链表长度和中序遍历
- 空间复杂度：O(logN)
