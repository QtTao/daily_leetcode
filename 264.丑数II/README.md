# [264. 丑数II](https://leetcode-cn.com/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode/)

`动态规划` `最小堆`

## 动态规划（先排序再保存）

### 解题思路

利用一个有序数组 nums 记录所有丑数。根据规律，第 n + 1 个丑数必然是第 n 个之前的某个丑数乘以 2，乘以 3 或乘以 5 的计算结果。 具体地说，利用三个指针 `i2`，`i3` 和 `i5` 指向数组 nums 的元素，最小的丑数就是 `nums[i2] * 2`，`nums[i3] * 3`
和 `nums[i5] * 5` 三者之中的最小值， 最后插入到数组成为最大的丑数。

1. 初始化 `i2`，`i3` 和 `i5` 指向数组的第一个元素 `nums[0]`
2. 重复下列步骤多次
    - 比较 `nums[i2] * 2`，`nums[i3] * 3` 和 `nums[i5] * 5` 三者大小，并将最小值插入数组
    - 如果最小值是 `nums[i2] * 2`，那么令 `i2 = i2 + 1`，i2 指针往后移动一位
    - 如果最小值是 `nums[i3] * 3`，那么令 `i3 = i3 + 1`，i3 指针往后移动一位
    - 如果最小值是 `nums[i5] * 5`，那么令 `i5 = i5 + 1`，i5 指针往后移动一位
3. `nums[n - 1]` 就是第 n 个丑数

### 复杂度

- 时间复杂度：O(N) 生成一个丑数需要 O(1)，那么 N 个丑数需要 O(N)
- 空间复杂度：O(N) 保存 N 个丑数

## 最小堆（先保存再排列）

### 解题思路

已知丑数 k，那么 2k，3k 和 5k 都是丑数。 利用最小堆这种数据结构，每次弹出堆顶的元素，然后分别乘以 2，3 和 5，如果出现过就舍弃，没出现过的丑数就加入堆中。 最后，第 n 个弹出的元素就是第 n 个丑数。

1. 创建最小堆用于存储生成的丑数，弹出最小值，哈希表 `seen` 用于标记堆中的出现过的元素，避免重复入堆，
2. 初始化将 1 加入堆中，并添加到 `seen` 中
3. 重复下列步骤
    - 弹出堆顶元素，分别乘以 2，3 和 5，生成的新丑数。如果新丑数不在 `seen` 中，加入堆中，同时加入 `seen`
4. 第 n 个弹出的堆顶就是第 n 个丑数

### 复杂度

- 时间复杂度：O(NlogN) 堆排序的平均时间复杂度是 O(NlogN)
- 空间复杂度：O(N) = O(N) 保存 N 个丑数 + O(<N) 最小堆保存丑数 + O(<N) 哈希表记录丑数是否出现过
