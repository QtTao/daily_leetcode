# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/)

`动态规划` `滑动窗口` `哈希表`

## [动态规划](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/)

### 解题思路

假设 `dp[j]` 为以 `s[j]` 为结尾的最长不重复子串的长度，固定 `j` 的位置，距离 `s[j]` 左边最近的重复字符 `s[i]`

- 当 `i < 0`，即 `s[j]` 左边没有重复字符，则 `dp[j] = dp[j - 1] + 1`
- 当 `dp[j - 1] < j - i`，说明 `s[i]` 在子串 `dp[j - 1]` 区间外，则 `dp[j] = dp[j - 1] + 1`（可以与上一种情况合并）
- 当 `dp[j - 1] >= j - i`, 说明 `s[i]` 在子串 `dp[j - 1]` 区间内，则 `dp[j] = j - i`
- `dp` 可初始化为 0，无重复最长子串的长度是以 `s` 每一个字符为结尾的 `dp` 中最大值，即 `max(dp[i]) 0 <= i <= len(s)`
- 左边界 `i` 的获取可以访问哈希表（统计各字符最后一次出现的索引位置），并每次循环需要更新哈希表中字符的索引位置

### 复杂度

- 时间复杂度：O(N) 遍历字符串 `s`
- 空间复杂度：O(1) 哈希表最多使用 128 个字符（字符的 ASCII 码范围为 0 ~ 127），为常量空间

## 滑动窗口（哈希表）

如果找出从每一个字符开始，不包含重复字符的最长子串，会发现每一个子串的结束位置也是递增的，这时可以考虑使用「滑动窗口」来解决

### 解题思路

1. 遍历字符串，同时使用哈希表记录各个字符最后出现的索引位置，和 `start` 变量记录无重复子串的起始位置
2. 当出现重复字符时候，利用当前字符在哈希表记录的上一个位置来更新无重复子串的起始位置，确保 `start` 和当前字符之间为无重复字符
3. 更新当前的无重复子串的最大长度和当前字符的最后索引位置

### **注意点**

1. 注意更新 `start` 的方式，如果直接采用上一个位置来更新，可能导致起始位置回退，比如 `tmmzuxt` ， 尾部 `t` 的出现让无重复子串的起始位置退回到索引 `0`，显然这是错误的
2. 减少最大长度的比较次数，当出现重复字符，且重复字符上次的位置位于无重复子串起始位置之后，说明起始位置需更新，最长子串比上一次的要短，无需进行比较

### 复杂度

- 时空复杂度与第一种方法一致
