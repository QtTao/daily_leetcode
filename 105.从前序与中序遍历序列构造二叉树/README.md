# [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/)

`递归` `迭代`

## 递归

- 前序遍历：根节点 -> 左子树 -> 右子树，对应的数组元素分布应为 `[根节点, 左子树遍历结果, 右子树遍历结果]`
- 中序遍历：左子树 -> 根节点 -> 右子树，对应的数组元素分布应为 `[左子树遍历结果, 根节点, 右子树遍历结果]`
- 递归子问题：在递归遍历某个子树的过程中，都将这颗子树看作一颗全新的树
- 递归结束条件：当前序数组或中序数组中的起始下标超过结束下标，说明已完成数组遍历，返回空节点

### 解题思路

1. 构建哈希表，存储中序数组中元素和下标的关系
2. 从前序数组中获取根节点的值，创建根节点 `root`
3. 基于哈希表，定位根节点在中序数组中的下标，并计算左子树节点个数
4. 递归构造左子树，并返回给 `root.left`
5. 递归构造右子树，并返回给 `root.right`

### 复杂度

- 时间复杂度：O(N) N 为二叉树的节点数
- 空间复杂度：O(N) = O(h) h 为二叉树的高度，递归调用栈深度 + O(N) 构建哈希表的空间

## [迭代](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--22/)

以下面的二叉树为例，

```bash
      3
    /   \
   9     7
  / \
 20  15
```

- 前序遍历 [3, 9, 20, 15, 7]
- 中序遍历 [20, 9, 15, 3, 7]

观察前序遍历和中序遍历的数组元素排列特点:

- 前序遍历的第一个元素 `3` 是二叉树的根节点
- 基于反证法，`9` 一定是 `3` 的左子树，`20` 一定是 `9` 的左子树
- 由于 `20` 与中序遍历中的第一个元素相同，说明 `15` 一定不是左子树，那么它可能是
    - `20` 的右子树
    - `9` 的右子树
    - `3` 的右子树
- 基于对中序遍历的分析，`15` 只能是 `9` 的右子树，由此发现前序遍历在遇到右子树节点之前节点的顺序 `[9, 20]` 正好与中序遍历的相反 `[20, 9]`
  ，为了模拟这种相反顺序，考虑利用栈后进先出的特点，遍历前序数组，并作为根节点的左子树，直到当前节点和中序数组的节点值相等，然后不断将栈顶元素弹出，找到最后一次相等的节点，作为该节点的右子树

### 解题思路

1. 初始化根节点和栈（用于维护还没考虑右节点的祖先节点），以及中序数组下标
2. 遍历前序数组，当出现了当前节点的值和中序遍历数组的值相等，寻找是谁的右子树
3. 不断弹出栈顶元素，直至遇到最后一个相等的节点，更新该节点的右子树，并入栈
4. 如果不相等，说明是左子树节点
5. 完成前序数组遍历，即完成二叉树的构造

## 复杂度

- 时间复杂度：O(N) N 为二叉树节点数
- 空间复杂度：O(h) h 为二叉树高度，利用栈存储的空间，最坏的情况是链状二叉树， O(N) 的空间复杂度
