# [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/)

`哈希表` `排序` `双指针`

## 哈希表

为了降低判断一个元素是否在集合中的时间复杂度，可以考虑使用哈希表存储元素，这样的时间复杂度为 O(1)

### 解题思路

1. 将两个给定的数组转换为成集合，分别是 `set1` 和 `set2`
2. 遍历元素个数较少的集合，判断该元素是否在另一个集合中，如果在，将它加入到结果数组 `ans` 中
3. 结束遍历，返回结果数组 `ans`

### 复杂度

- 时间复杂度：O(M + N) 其中 M 和 N 分别为两个数组的长度，将数组转换为集合，需要 O(M + N)，另外判断元素是否在集合需要 O(min(M, N))，所以整体时间复杂度为 O(M + N)
- 空间复杂度：O(M + N) 集合需要 O(M + N) 的空间来存储数组元素

## 排序 + 双指针

如果两个数组是有序，可以使用双指针得到两个数组的交集

### 解题思路

1. 首先对两个数组进行排序，然后使用两个指针分别遍历两个数组，i 对应 nums1，j 对应 nums2
2. 开始遍历两个数组
    - 当 `nums1[i] == nums2[j]`，且结果数组 `ans` 为空，或当前元素不等于上一个加入结果数组的元素，将当前元素加入结果数组
    - 当 `nums1[i] > nums2[j]`，由于数组元素一定是递增的，所以指针右移一位 `j += 1`
    - 当 `nums1[i] < nums2[j]`，由于数组元素一定是递增的，所以指针右移一位 `i += 1`
3. 当至少有一个指针超出数组范围时，遍历结束，返回结果数据 `ans`

### 复杂度

- 时间复杂度：O(MlogM + NlogN) 其中 O(MlogM) 和 O(NlogN) 分别为两个数组排序的时间复杂度，另外双指针寻找交集元素的时间复杂度为 O(M + N)，所以整体时间复杂度为 O(MlogM + NlogN)
- 空间复杂度：O(logM + logN) 快速排序所需的额外空间
